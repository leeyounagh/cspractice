## 실행 컨텍스트에 대해 설명해주세요

코드를 실행하는데 필요한 환경을 제공하는 객체
스코프가 호출되는 위치와 상관없이 어디에 선언되있느냐에 따라 정적으로 결정되고
하나의 컨텍스트 개념으로 묶었기때문에 자바스크립트 엔진은 더 빠르고 효율적으로 식별자를
결정할수 있게 되었다.

예시)

function add(hi){
console.log(hi)
// add라는 함수에 hi라는 매개 변수를 받았기 때문에 add 함수는 hi라는 변수를 출력하게 됨
console.log(메롱)
// add라는 함수에 메롱이라는 변수가 없기때문에 자바스크립트엔진은 상위 스코프에서
//해당 변수를 찾게 된다. 타고타고 올라가 전역스코프에서도 해당값이 없다면,
//해당 변수가 없다는 결론을 내놓게 됨
}

## var const let에 대해 설명하고 차이점을 말씀해 주세요

var, const, 그리고 let은 JavaScript에서 변수를 선언하는 키워드입니다.

var 키워드는 ES5 이전에 사용되던 변수 선언 방식입니다.
함수 스코프(function scope)를 가지며, 함수 내에서 선언된 변수는 함수 내에서만 유효합니다.
호이스팅(Hoisting)이 발생하여 변수 선언부가 스코프의 맨 위로 끌어올려집니다.
중복 선언이 가능하며, 재할당이 가능합니다.

특징: 초기화와 할당이 동시에 이루어진다. 이떄 변수를 출력할경우 undifiend를 반환한다.

const 키워드는 상수(constant)를 선언하는 데 사용되는 키워드입니다.
블록 스코프(block scope)를 가지며, 중괄호({}) 내에서 선언된 변수는 블록 내에서만 유효합니다.
상수로 선언된 변수는 재할당이 금지됩니다. 한 번 할당된 값은 변경할 수 없습니다.
상수는 선언과 동시에 초기화되어야 합니다.

특징: 최상단에서 초기화가 되고, 선언부에 도달했을때 할당이 이루어짐<= 일시적 사각지대에 빠짐
이떄 선언부 이전에 식별자를 참조할수 없는경우 reference error가 발생한다.

let 키워드는 블록 스코프를 가지는 변수를 선언하는 데 사용되는 키워드입니다.
let으로 선언된 변수는 중괄호({}) 내에서만 유효합니다.
호이스팅이 발생하지만, 변수 선언 이전에 접근하면 "참조 에러 (ReferenceError)"가 발생합니다.
중복 선언이 불가능하며, 재할당이 가능합니다.
주요한 차이점은 var는 함수 스코프를 가지고 있고, const와 let은 블록 스코프를 가진다는 점입니다. 함수 스코프는 함수 내에서 선언된 변수가 함수 전체에서 유효하다는 것을 의미합니다. 반면에 블록 스코프는 중괄호({})로 둘러싸인 영역 내에서 변수가 유효하다는 것을 의미합니다.

특징: 최상단에서 초기화가 되고, 선언부에 도달했을때 할당이 이루어짐<= 일시적 사각지대에 빠짐
이떄 선언부 이전에 식별자를 참조할수 없는경우 reference error가 발생한다.

## 스코프란?

스코프(Scope)는 변수와 함수의 유효 범위를 나타내는 개념입니다. 즉, 스코프는 변수와 함수에 접근할 수 있는 영역이라고 할 수 있습니다. 종류에는 함수스코프와 블록스코프가 있음

함수 스코프(Function Scope): 함수 내에서 선언된 변수와 함수는 해당 함수 내에서만 접근 가능한 스코프입니다. 함수 스코프는 함수가 호출될 때마다 생성되며, 함수 실행이 끝나면 스코프도 사라집니다.

블록 스코프(Block Scope): ES6(ECMAScript 2015)부터 도입된 let과 const 키워드를 사용하여 선언된 변수는 해당 블록({}) 내에서만 접근 가능한 스코프입니다. 이전에는 var를 사용한 변수 선언도 함수 스코프에 속했지만, 블록 스코프에는 속하지 않습니다.

스코프는 변수를 식별하고, 변수의 유효 범위를 결정하는 역할을 합니다. 변수가 선언된 위치에 따라 스코프가 결정되며, 해당 스코프 내에서 변수에 접근할 수 있습니다. 변수를 참조할 때 JavaScript 엔진은 현재 스코프에서부터 가장 가까운 스코프로 올라가며 변수를 탐색합니다. 이를 **스코프 체인**(Scope Chain)이라고 합니다.

- 추가 자바스크립트에서 함수는 태어나면 자신의 내부 슬롯에 상위스코프의 참조를 저장한다.

## 호이스팅이란?

호이스팅(Hoisting)은 JavaScript에서 변수와 함수 선언이 해당 스코프의 상단으로 "끌어올려지는" 동작을 말합니다. 이는 코드 실행 전에 변수와 함수 선언이 메모리에 할당되는 것처럼 동작하여, 선언 이전에도 사용할 수 있다는 특징을 가지고 있습니다.// 요약하면 선언전에도 변수를 참조할수 있는 현상

## 상태관리란?

상태는 간단히 말해서 변화하는 데이터
ui의 동작으로 표현되는 데어터
즉 사용자의 액션에 따라서 변경될수 있는 컴포넌트의 부분을 나타내는
자바스크립트 객체
상태관리란?
=> 변화하는 데이터 관리 하는것
계속 변화하는 데이터를 알맞게 관리하기 위해 나온 개념

## 상태관리를 하는 이유와 평소 state관리를 어떻게 하는지?

1. 사용자는 페이지가 바뀔때마다 매번 데이터를 가져오는 불편함을 가져야됐음/
   데이터가 바뀌어도 페이지가 다시 렌더링 되길 원하지 않고
   변화된 부분만 쏙쏙 바뀌길 바람
   예시) 좋아요 눌렀을떄 바로바로 상태가 변함
2. 상태가 복잡해질수록 상태들이 페이지 내부에서
   어떻게 흘러가고 그에따라 ui가 어떻게 변하는지
   알아차리기가 굉장히 어려웠음 + 이런 상태값이 비동기적이라면?
   따라서 이러한 상태들이 언제 어떻게 변화하는지 알기위하여 나타나게됨

   앱이 커지면 중간에 거쳐할 컴포넌트들이 많아짐(props drilling 이슈)/ 따라서 중대형 프로젝트에 상태관리가 빛을 봄

   평소 state관리 어떻게 하는지?
   => 주로 리덕스를 이용하여 상태관리를 하고 있습니다. 단일 스토어에서 상태를 관리하며, 중앙 집중화된 데이터 스토어를 사용합니다. 이를 통해 여러 컴포넌트에서 동일한 상태를 공유하고, 데이터의 일관성을 유지할 수 있어 전역적으로 state를 사용해야될때 리덕스를 사용하고 있습니다.

## 반응형 프로그래밍이란?

데이터가 변하면 그 변화하는 데이터에 따라서 알아서 반응하는 프로그래밍
컴포넌트를 구독하고 변화가 일어날때마다 알아서 반응을 하는 프로그래밍

=> 리액트는 반응형 프로그래밍이 아니다.

## 리덕스를 사용하는 이유는?

프로젝트가 커지면 커질수록 상태값이 언제 어떻게 변화하는지 알수 없음
리덕스는 단방향 패턴을 가지고 있어 상태 관리에 용이함

## 리액트의 장점은?

가상 Dom구조라고 할수 있습니다. 리액트는 초기에 빌드될때 dom과 유사한 가상돔 트리를 만듭니다.
이후에 페이지당 상태가 변화 할때마다, 기존의 dom과 비교하여 변화한부분만 렌더링 할수 있습니다.
이에따라 불필요한 DOM 조작과 렌더링을 줄여주어 성능 향상을 가져옵니다.

## flux 패턴이란?

Facebook에서 개발함/대규모 애플리케이션에서 데이터 흐름을 일관성 있게 관리함으로써 프로그램의 예측가능성(Predictability)을 높이기 위함
Flux는 사용자 입력을 기반으로 Action을 만들고 Action을 Dispatcher에 전달하여 Store(Model)의 데이터를 변경한 뒤 View에 반영하는 단방향의 흐름으로 애플리케이션을 만드는 아키텍처입니다
단방향 데이터 흐름, 액션 (Action), 디스패처 (Dispatcher),스토어 (Store),뷰 (View)

## 함수와 일급 객체

함수 (Function):
함수는 일련의 작업을 수행하는 코드 블록입니다. 일반적으로 함수는 특정한 기능을 수행하고 그 결과를 반환합니다. 함수는 코드의 재사용성과 모듈화를 촉진하며, 프로그램을 조직화하고 유지보수하기 쉽게 만듭니다. 함수는 주로 호출되어 실행되지만, 함수 자체를 값으로 사용하거나 변수에 할당할 수도 있습니다.

일급 객체 (First-Class Object):
일급 객체란 프로그래밍 언어에서 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 말합니다. 이러한 객체는 변수에 할당하거나 데이터 구조에 저장할 수 있으며, 함수의 인자로 전달하거나 함수의 반환값으로 사용할 수 있습니다. 일급 객체는 다른 객체에 적용 가능한 연산인 "일급 함수"를 가질 수 있어서 함수를 값으로 다룰 수 있는 것을 의미합니다. 즉, 함수를 변수에 할당하고, 다른 함수의 인자로 전달하거나 반환할 수 있습니다.

## 클로저란?

클로저는 반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수

예시)
function outerFunc() {
var x = 10;
var innerFunc = function () { console.log(x); };
innerFunc();
}

outerFunc(); // 10
//함수 outerFunc 내에서 내부함수 innerFunc가 선언되고 호출되었다. 이때 내부함수 innerFunc는 자신을 포함하고 있는 외부함수 outerFunc의 변수 x에 접근할 수 있다.

## 렉시컬환경이란?

렉시컬 환경(Lexical Environment)은 자바스크립트 엔진이 변수, 함수 등의 식별자를 저장하고 접근할 수 있는 환경을 의미합니다.

## vite를 Cra와 비교해서 설명 해보십쇼?

npm(Vite)와 CRA(Create React App)는 모두 리액트 애플리케이션의 개발 환경을 설정해주는 도구입니다.

Vite:
빠른 개발 환경 제공
네이티브 ES 모듈(ESM) 지원으로 더 작은 번들 크기와 빠른 모듈 로딩 가능
다양한 플러그인 생태계 제공
확장성이 높아 다른 프레임워크 및 라이브러리와 함께 사용 가능

CRA:
간편한 시작을 위한 미리 구성된 프로젝트 템플릿 제공
추상화된 설정으로 개발자가 복잡한 설정과 구성을 걱정하지 않아도 됨
개발 생산성 향상을 위한 초점 제공
업데이트를 통한 자동적인 기능 업데이트 지원
두 도구 모두 리액트 애플리케이션 개발을 쉽게 시작할 수 있도록 도와주지만, Vite는 빠른 개발 환경과 ES 모듈 지원, 플러그인 생태계를 강점으로 가지고 있으며, CRA는 간편한 시작과 추상화된 설정, 개발 생산성 향상을 중점으로 제공됩니다. 선택은 프로젝트의 요구사항과 개발자의 선호도에 따라 달라질 수 있습니다.

## 브라우저가 렌더링되는 과정을 설명해 보시오

1. 사용자가 브라우저에 접속할때 웹사이트에 접속
2. dns를 통해 서버의 아이피 주소를 파악
3. 브라우저와 서버가 3way handshake를 완료 //
4. 브라우저가 서버에게 http request를 한다.
5. 브라우저가 서버로부터 http response를 한다.
6. html parsing하여 dom tree 생성
7. 스타일 태그가 나오면 cssom 트리 생성
8. 스크립트 태그가 나오면 ast 생성후 실행
9. dom+ cssom 트리를 합쳐서 렌더트리 생성 // 지금까지의 과정을 contruction 이라 한다.
10. 렌더링 엔진은 rendering tree에있는 node를 배치
11. rendering tree에 있는 node의 ui를 그림
12. render tree에있는 node를 순서대로 구성 //여기까지의 과정은 operation이라한다.
    13 . 사용자에게 결과화면 출력

## 리덕스 말고 다른 상태관리 라이브러리 아는것에 대해 리덕스와 비교하여 설명해 보시오

상태관리 라이브러리가 여러가지가 있지만, context api와 비교해보자면
context api는 초기세팅이 쉽지만, 자식 컴포넌트에서 상태값이 변할경우, 부모컴포넌트에서도
리렌더링이 일어난다고 들었습니다. 따라서 리덕스를 선택하였는데요
컴포넌트 간의 상태를 중앙 집중적으로 관리함으로써 자식 컴포넌트에서 상태를 변경하더라도 해당 상태는 리덕스 스토어에 저장되고, 부모 컴포넌트의 상태와는 직접적인 관계를 맺지 않는것으로 알고 있습니다.

## 버츄어돔과 리얼돔의 차이를 설명해주세요.

Real DOM:

실제 웹 페이지의 DOM 구조를 나타냅니다.
HTML 문서의 요소(element)들을 트리 구조로 표현합니다.
웹 브라우저에서 DOM을 조작하고 업데이트하는 데 사용됩니다.
변경된 상태에 따라 DOM을 업데이트하는 과정은 비용이 큽니다. 대규모 애플리케이션의 경우, DOM 조작이 빈번하게 일어나면 성능 저하가 발생할 수 있습니다.

Virtual DOM:

실제 DOM을 추상화한 가벼운 복사본입니다.
리액트에서 상태 변화를 추적하고, DOM 업데이트를 최적화하는 데 사용됩니다.
변경된 상태에 따라 Virtual DOM을 업데이트하고, 변경 사항을 실제 DOM에 일괄적으로 적용합니다.
Virtual DOM은 메모리 상에서 작동하므로 실제 DOM에 접근하는 비용이 낮습니다.
