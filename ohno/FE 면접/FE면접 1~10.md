## 1. 상태관리를 왜 할까요? 그리고 평소 state관리는 어떻게 하시나요?

상태 관리는 애플리케이션의 데이터를 효율적으로 관리하고 업데이트하는 방법입니다. 상태를 관리하는 이유는 데이터의 공유, 상태 업데이트 관리, 비동기 작업 관리를 위해서입니다.

평소에는 작은 규모의 애플리케이션에서는 로컬 상태 관리를 사용하고(useContext같은것), 큰 규모의 애플리케이션에서는 전역 상태 관리 라이브러리를 활용합니다. 상태 관리 패턴을 따라 액션, 상태, 리듀서를 사용하여 상태를 업데이트합니다.

```markdown
1. 사용자는 페이지가 바뀔때마다 매번 데이터를 가져오는 불편함을 가져야됐음/
   데이터가 바뀌어도 페이지가 다시 렌더링 되길 원하지 않고
   변화된 부분만 쏙쏙 바뀌길 바람
   예시) 좋아요 눌렀을떄 바로바로 상태가 변함
2. 상태가 복잡해질수록 상태들이 페이지 내부에서
   어떻게 흘러가고 그에따라 ui가 어떻게 변하는지
   알아차리기가 굉장히 어려웠음 + 이런 상태값이 비동기적이라면?
   따라서 이러한 상태들이 언제 어떻게 변화하는지 알기위하여 나타나게됨

앱이 커지면 중간에 거쳐할 컴포넌트들이 많아짐(props drilling 이슈)/
따라서 중대형 프로젝트에 상태관리가 빛을 봄

평소 state관리 어떻게 하는지?
=> 주로 리덕스를 이용하여 상태관리를 하고 있습니다. 단일 스토어에서 상태를 관리하며,
중앙 집중화된 데이터 스토어를 사용합니다. 이를 통해 여러 컴포넌트에서 동일한 상태를 공유하고,
데이터의 일관성을 유지할 수 있어 전역적으로 state를 사용해야될때 리덕스를 사용하고 있습니다.
```

```
상태관리란?
=> 변화하는 데이터 관리 하는것
계속 변화하는 데이터를 알맞게 관리하기 위해 나온 개념 //ui의 동작으로 표현되는 데이터
```

## 2. Redux가 무엇인가요, 왜 Redux를 사용하시나요?

Redux는 JavaScript 애플리케이션의 상태 관리를 위한 도구로, 예측 가능한 상태 업데이트와 중앙 집중화된 상태 관리를 제공합니다. Redux를 사용하면 상태를 효율적으로 관리하고 여러 컴포넌트에서 상태를 공유할 수 있습니다. 이로써 애플리케이션의 예측 가능성과 확장성을 높일 수 있습니다.

## 3. Redux 말고 다른 전역 상태관리 아는 것 하나 와 차이점을 말해주세요

Redux 외에도 MobX는 또 다른 전역 상태 관리 라이브러리입니다.
Redux와 MobX는 모두 전역 상태 관리를 위한 라이브러리입니다. Redux는 명확한 문법과 일관된 패턴을 갖고 있으며, MobX는 간단하고 직관적인 문법을 가지고 있습니다. 또한, Redux는 React와의 통합이 강조되고 MobX는 코드를 간소화할 수 있는 특징적인 문법을 가지고 있습니다.

## 4. 버츄얼 돔과 리얼 돔의 차이를 설명해주세요

버츄얼 돔(Virtual DOM)은 메모리 상에 존재하는 가상의 돔 트리로, 돔 변경을 추적하고 효율적으로 업데이트하는 데 사용됩니다. 리얼 돔(Real DOM)은 브라우저의 실제 HTML 문서 구조를 나타내는 돔 트리입니다. 버츄얼 돔은 성능 최적화를 위해 돔 조작과 렌더링을 효율적으로 수행하는 방법 중 하나입니다.

## 5. useRef에 대해 설명해보세요

useRef는 React Hooks의 하나로, 함수형 컴포넌트에서 참조(ref)를 생성하고 관리하는 데 사용되는 기능입니다. useRef를 사용하면 DOM 요소 또는 컴포넌트 인스턴스와 같은 값을 유지할 수 있습니다.

useRef는 **비제어 컴포넌트**다!

불필요한 리렌더링을 막을수 있음// useState를 사용할경우 타자 하나 하나 칠때마다 렌더링이 일어남⇒ 성능적인 이슈가 있을경우 디바운스처리나 쓰로틀링을 사용하고, useRef는 성능적인 이슈가 아니고 불필요한 리렌더링을 막을경우 사용

⇒ useRef로 관리되는 값이 변경되었을 때 컴포넌트를 강제로 리렌더링하고 싶다면, useRef의 .current 속성을 수정하는 방법을 사용할 수 있습니다. 이 경우 컴포넌트는 useRef를 참조하는 곳에서 다시 렌더링됩니다. 하지만 이러한 사용은 일반적으로 권장되지 않으며, 상태 관리를 위해 useState나 useReducer를 사용하는 것이 좋습니다.

**제어 컴포넌트:** 제어 컴포넌트의 값은 **항상 최신값**을 유지한다. 새로운 입력 값이 생길때 마다 상태를 새롭게 갱신한다. 이는 데이터와 UI에서 입력한 값이 항상 동기화됨을 알 수 있다. ↔ **비제어 컴포넌트:** 필드에서 값을 트리거 해야 값을 얻을 수 있다. 사진에선 [전송] 버튼을 클릭하면 console에 값이 찍힌다. [전송]버튼을 클릭해 트리거 하기 전까지의 값은 변경되지 않는다.

## 6. useEffect의 실행 순서에 대해 설명해주세요.

useEffect의 실행 순서는 컴포넌트의 마운트 시에 콜백 함수가 실행되고, 이후 의존성 배열을 검사하여 변경 여부를 확인합니다. 변경이 있을 경우 콜백 함수가 다시 실행되고, 변경이 없을 경우 이전에 실행된 클린업 함수가 실행됩니다.

## 7. var, let, const의 차이에 대해 알려주세요.

var는 ES5 이전의 변수 선언 방식이며, 함수 스코프를 가지고 중복 선언이 가능합니다. let은 ES6에서 도입된 블록 스코프를 가지는 변수 선언 방식이며, 변수의 재할당이 가능합니다. const는 상수를 선언하는 방식으로, 값의 재할당이 불가능합니다.

## 8. Async/Await와 Promise의 차이

- 문법적인 차이: Promise는 체이닝을 통해 비동기 작업을 처리하는 반면, Async/Await는 비동기 코드를 동기적인 스타일로 작성할 수 있게 합니다.
- 에러 처리: Promise는 then()과 catch()를 사용하여 에러 처리를 합니다. 반면, Async/Await는 try-catch 문을 사용하여 에러를 처리합니다.
- 가독성: Async/Await는 비동기 코드를 동기적으로 작성할 수 있어 가독성이 좋습니다.

요약하면, Promise는 비동기 작업을 처리하는 객체이고, Async/Await는 Promise를 기반으로 한 간결한 비동기 코드 작성을 위한 문법입니다.

## 9. 데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은?

무한 스크롤 구현 시에는 성능, 네트워크 요청 최적화, 메모리 관리, 사용자 경험, 에러 처리 등을 중요하게 고려해야 합니다.
