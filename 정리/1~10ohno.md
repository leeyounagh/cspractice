## 2. Redux가 무엇인가요, 왜 Redux를 사용하시나요?

Redux는 JavaScript 애플리케이션의 상태 관리를 위한 도구로, 예측 가능한 상태 업데이트와 중앙 집중화된 상태 관리를 제공합니다. Redux를 사용하면 상태를 효율적으로 관리하고 여러 컴포넌트에서 상태를 공유할 수 있습니다. 이로써 애플리케이션의 예측 가능성과 확장성을 높일 수 있습니다.

예상 질문

1. Redux 외에도 상태 관리를 위해 어떤 다른 도구나 라이브러리를 사용해 본 적이 있나요?<br>
   -> 다른 상태 관리 도구나 라이브러리: MobX, Zustand, Recoil (사용해본적이 없어요 ㅠㅠ)
2. Redux의 주요 개념인 액션(Action), 리듀서(Reducer)와 스토어(Store)에 대해 좀 더 자세히 설명해 줄 수 있을까요?<br>
   ->

   - 액션(Action): 상태 변경을 나타내는 객체
   - 리듀서(Reducer): 이전 상태와 액션을 받아 새로운 상태를 반환하는 순수 함수
   - 스토어(Store): 애플리케이션의 전체 상태를 보유하고, 상태의 업데이트를 관리하는 객체

3. Redux의 단점이나 사용 시 주의해야 할 점은 무엇인가요?<br>
   -> 복잡한 설정과 코드 구조
   상태 업데이트 로직의 중앙 집중화로 인한 추가적인 작업 필요
   작은 규모의 애플리케이션에서는 과도한 복잡성을 초래할 수 있음
4. Redux와 React Hooks를 함께 사용해 본 적이 있나요? 그렇다면 두 가지 상태 관리 방식의 차이와 각각의 장단점에 대해 어떻게 생각하시나요?<br>
   -> Redux는 클래스형 컴포넌트와 함께 주로 사용되었지만, React Hooks를 사용하여 함수형 컴포넌트에서도 Redux를 활용할 수 있게 되었습니다.
   Hooks를 사용하면 Redux보다 더 간단하고 직관적인 코드 작성이 가능해집니다.
5. Redux 외에도 상태 관리를 위해 컨텍스트(Context) API나 MobX와 같은 다른 도구를 사용한 적이 있나요? 그렇다면 Redux와 비교했을 때 어떤 점이 다른지 알려주세요.<br>
   -> 컨텍스트(Context) API: Redux보다 간단하게 상태를 공유할 수 있는 기능 제공
   MobX: 더 간결한 코드 구조와 자동 상태 추적 기능 제공
   Zustand: 작은 규모의 애플리케이션에서 사용하기 쉽고, 리액트 훅 기반의 상태 관리 도구
   Recoil: 원자성(atom) 단위로 상태를 관리하며, 대규모 애플리케이션에서 유용한 기능 제공
   (사용해본적이 없어용.. ㅠㅠㅠㅠ)

## 3. Redux 말고 다른 전역 상태관리 아는 것 하나 와 차이점을 말해주세요

Redux 외에도 MobX는 또 다른 전역 상태 관리 라이브러리입니다.
Redux와 MobX는 모두 전역 상태 관리를 위한 라이브러리입니다. Redux는 명확한 문법과 일관된 패턴을 갖고 있으며, MobX는 간단하고 직관적인 문법을 가지고 있습니다. 또한, Redux는 React와의 통합이 강조되고 MobX는 코드를 간소화할 수 있는 특징적인 문법을 가지고 있습니다.

예상질문

1. Redux와 MobX 중에서 어떤 상황에서 어떤 것을 선택하는 것이 적합할까요?<br>
   -> Redux의 경우 예측 가능한 상태 업데이트와 Redux DevTools의 디버깅 기능이 필요한 복잡한 애플리케이션에 적합합니다.
   MobX의 경우는 코드량을 최소화하고 단순한 구현을 선호하는 작은 규모의 애플리케이션에 적합합니다.
2. 전역 상태 관리가 필요하지 않은 경우에는 로컬 상태 관리만으로 충분한가요, 아니면 전역 상태 관리를 사용하는 것이 더 나을까요?<br>
   -> 전역 상태 관리는 애플리케이션 규모와 복잡성에 따라 달라집니다. 작은 규모의 애플리케이션에서는 로컬 상태 관리만으로 충분할 수 있지만, 상태 공유와 관리의 편의성을 위해 전역 상태 관리가 필요한 경우도 있습니다.

## 4. 버츄얼 돔과 리얼 돔의 차이를 설명해주세요

버츄얼 돔(Virtual DOM)은 메모리 상에 존재하는 가상의 돔 트리로, 돔 변경을 추적하고 효율적으로 업데이트하는 데 사용됩니다. 리얼 돔(Real DOM)은 브라우저의 실제 HTML 문서 구조를 나타내는 돔 트리입니다. 버츄얼 돔은 성능 최적화를 위해 돔 조작과 렌더링을 효율적으로 수행하는 방법 중 하나입니다.

예상질문

1. Virtual DOM을 사용하는 이유는 무엇인가요?<br>
   -> Virtual DOM을 사용하는 이유는 돔 조작과 렌더링 과정에서의 성능 개선을 위해입니다. 실제 돔을 직접 조작하는 것보다 메모리 상에서 가상 돔을 조작하고 변경된 부분만 실제 돔에 적용함으로써 효율적인 업데이트를 가능하게 합니다.
2. Virtual DOM을 사용하는 것이 항상 성능 향상에 도움이 되는가요? 그렇지 않다면 어떤 상황에서 사용하는 것이 좋을까요?<br>
   -> Virtual DOM을 사용하는 것이 항상 성능 향상에 도움이 되는 것은 아닙니다. 작은 규모의 애플리케이션이나 돔 조작이 적은 경우에는 실제 돔 조작이 더 효율적일 수 있습니다.
3. Virtual DOM을 구현하기 위한 라이브러리나 프레임워크로는 어떤 것들이 있는지 알고 있나요?<br>
   -> React는 가장 널리 사용되는 Virtual DOM 라이브러리입니다. 다른 프레임워크나 라이브러리에서도 가상 돔을 구현하는 방법이 제공될 수 있습니다.
4. Virtual DOM을 사용할 때 주의할 점은 무엇인가요?<br>
   -> Virtual DOM을 사용할 때에는 돔 조작이 불필요한 경우를 최대한 줄이고, 효율적인 업데이트 전략을 사용하는 것이 중요합니다. 불필요한 가상 돔 조작은 오히려 성능을 저하시킬 수 있습니다.

## 6. useEffect의 실행 순서에 대해 설명해주세요.

useEffect의 실행 순서는 컴포넌트의 마운트 시에 콜백 함수가 실행되고, 이후 의존성 배열을 검사하여 변경 여부를 확인합니다. 변경이 있을 경우 콜백 함수가 다시 실행되고, 변경이 없을 경우 이전에 실행된 클린업 함수가 실행됩니다.

예상질문

1. 의존성 배열은 어떤 역할을 하며, 어떤 상황에서 어떻게 사용해야 하는지 설명해주세요.<br>
   -> useEffect의 의존성 배열은 해당 훅이 실행되는 조건을 제어하는 역할을 합니다. 의존성 배열에 포함된 값이 변경되었을 때에만 useEffect의 콜백 함수가 실행됩니다. 의존성 배열이 빈 배열인 경우(의존성이 없는 경우), useEffect는 컴포넌트가 처음 마운트될 때에만 실행됩니다. 의존성 배열을 사용하여 특정 상태나 프로퍼티의 변경을 감지하고 필요한 동작을 수행할 수 있습니다.

## 7. var, let, const의 차이에 대해 알려주세요.

var는 ES5 이전의 변수 선언 방식이며, 함수 스코프를 가지고 중복 선언이 가능합니다. let은 ES6에서 도입된 블록 스코프를 가지는 변수 선언 방식이며, 변수의 재할당이 가능합니다. const는 상수를 선언하는 방식으로, 값의 재할당이 불가능합니다.

예상질문

1. 변수를 선언할 때 어떤 상황에서 var, let, const를 선택하는 것이 좋을까요?<br>
   -> var: ES5 이전의 환경이거나 호환성을 고려해야 할 때, 함수 스코프가 필요한 경우, 중복 선언이 필요한 경우에 사용합니다.
   let: ES6 이후의 환경에서 주로 사용되며, 블록 스코프를 가지기 때문에 더 안전하게 변수를 제한적인 범위에서 사용하고 싶을 때 선택합니다. 변수의 재할당이 필요한 경우에도 사용됩니다.
   const: 상수를 선언할 때 사용합니다. 값의 재할당이 필요 없는 경우에 선택하며, 한 번 할당된 값은 변경할 수 없습니다. 일반적으로 변경이 없는 값이나 객체를 선언할 때 사용합니다.

## 8. Async/Await와 Promise의 차이

- 문법적인 차이: Promise는 체이닝을 통해 비동기 작업을 처리하는 반면, Async/Await는 비동기 코드를 동기적인 스타일로 작성할 수 있게 합니다.
- 에러 처리: Promise는 then()과 catch()를 사용하여 에러 처리를 합니다. 반면, Async/Await는 try-catch 문을 사용하여 에러를 처리합니다.
- 가독성: Async/Await는 비동기 코드를 동기적으로 작성할 수 있어 가독성이 좋습니다.

요약하면, Promise는 비동기 작업을 처리하는 객체이고, Async/Await는 Promise를 기반으로 한 간결한 비동기 코드 작성을 위한 문법입니다.

예상질문

1. Async/Await와 Promise 중 어떤 것을 사용하는 것이 더 좋을까요? 어떤 상황에서 각각을 선택하는 것이 적합할까요?<br>
   -> Promise: 비동기 작업을 처리하고자 할 때, 특히 연속적인 비동기 호출이 필요한 경우에 유용합니다. 체이닝을 통해 작업의 흐름을 명확하게 표현할 수 있습니다.
   Async/Await: 동기적인 스타일로 비동기 코드를 작성하고자 할 때 가독성이 좋습니다. 비동기 작업의 결과를 변수에 할당하여 직접 참조할 수 있으며, 에러 처리도 간편합니다.

따라서, 각 상황에 따라 선택할 수 있습니다. 연속적인 비동기 작업이 필요하거나 코드를 더 세밀하게 제어하고자 할 때는 Promise를 사용하고, 코드의 가독성과 동기적인 스타일을 선호할 때는 Async/Await를 사용할 수 있습니다.

## 9. 데이터 10,000개를 가지고 무한 스크롤 구현시에 가장 중요하게 고려해야 할점은?

무한 스크롤 구현 시에는 성능, 네트워크 요청 최적화, 메모리 관리, 사용자 경험, 에러 처리 등을 중요하게 고려해야 합니다.

예상질문

1. 무한 스크롤 구현 시에 메모리 관리 측면에서 어떤 고려사항이 있을까요?<br>
   ->가비지 컬렉션: 무한 스크롤로 인해 동적으로 생성되는 컴포넌트나 데이터를 적절하게 관리해야 합니다. 더 이상 필요하지 않은 컴포넌트나 데이터는 가비지 컬렉션에 의해 자동으로 해제되어 메모리를 절약할 수 있습니다.<br><br>
   가상화(Virtualization): 대량의 데이터를 처리할 때 모든 데이터를 동시에 렌더링하는 것은 비효율적일 수 있습니다. 가상화 기술을 사용하여 현재 보이는 영역만 렌더링하고 나머지는 동적으로 로딩하는 방식으로 메모리를 효율적으로 관리할 수 있습니다.<br><br>
   메모리 누수 방지: 이벤트 핸들러 등에 대한 적절한 등록 및 해제, 의존성 관리 등을 통해 메모리 누수를 방지해야 합니다. 무한 스크롤 구현 시에는 반복적으로 생성되고 제거되는 컴포넌트나 데이터의 메모리 관리에 특히 신경써야 합니다.<br><br>
   데이터 청크 처리: 대량의 데이터를 한 번에 로딩하지 않고 청크(chunk) 단위로 나누어 처리하면 메모리 사용을 최적화할 수 있습니다. 필요한 데이터만 로딩하여 사용자 경험을 향상시키면서도 메모리 부담을 줄일 수 있습니다.

이러한 점들을 고려하여 메모리 관리를 최적화하는 것이 중요합니다.
