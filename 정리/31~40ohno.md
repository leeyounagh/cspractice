## 33. Promise와 Callback 차이점은

Promise와 Callback은 비동기 처리를 위한 두 가지 접근 방식입니다.

Callback은 함수를 매개변수로 전달하여 비동기 작업이 완료되면 호출되는 콜백 함수를 정의하는 방식입니다. 콜백 함수는 작업이 완료된 후 처리할 로직을 포함하고 있으며, 주로 콜백 헬(callback hell)이라는 문제가 발생할 수 있습니다. 콜백 함수를 중첩하여 사용하면 코드의 가독성과 유지보수가 어려워집니다.

Promise는 콜백 헬 문제를 해결하기 위한 개념으로 등장했습니다. Promise는 비동기 작업의 결과를 나타내는 객체입니다. 비동기 작업이 완료되면 성공 또는 실패를 알리는 resolve와 reject 함수를 호출하여 Promise 객체의 상태를 변경합니다. Promise는 then과 catch 메서드를 제공하여 성공과 실패에 대한 처리를 간편하게 할 수 있습니다. 또한 여러 개의 비동기 작업을 순차적으로 실행하거나 병렬로 실행할 수 있는 메서드들도 제공합니다.

정리하면 Callback은 비동기 작업의 완료 후 호출되는 함수를 매개변수로 전달하는 방식이며, Promise는 비동기 작업의 결과를 나타내는 객체입니다. Callback은 콜백 헬이 발생할 수 있고 가독성이 떨어질 수 있으나, Promise는 콜백 헬을 피하고 보다 간결하고 유지보수하기 쉬운 비동기 코드를 작성할 수 있게 해줍니다.

예상질문 <br>
->

1. _Promise에서 동시에 실행되는 비동기 작업의 처리 방식에 대해 설명해주세요._<br><br>
   Promise에서 동시에 실행되는 비동기 작업은 Promise.all 메서드를 사용하여 처리할 수 있습니다. Promise.all은 여러 개의 Promise를 배열로 받아서 모든 Promise가 처리될 때까지 기다린 후, 모든 Promise의 결과를 배열로 반환합니다. 이를 활용하여 여러 개의 비동기 작업을 병렬로 실행하고, 모든 작업이 완료된 후에 결과를 처리할 수 있습니다.

2. _Promise와 Async/Await은 어떤 관계인가요?_<br><br>
   Promise와 Async/Await은 비동기 작업을 처리하기 위한 JavaScript의 두 가지 접근 방식입니다. Promise는 콜백 헬(callback hell) 문제를 해결하고 비동기 코드를 보다 간결하게 작성할 수 있게 해줍니다. Async/Await은 Promise를 기반으로 한 구문적인 설탕(syntactic sugar)으로, 비동기 코드를 동기적인 스타일로 작성할 수 있도록 도와줍니다.
3. _Promise의 상태(state)에는 어떤 값들이 있고, 각각 어떤 의미를 가지나요?_<br><br>

- Pending(대기): 비동기 작업이 아직 완료되지 않은 상태입니다.
- Fulfilled(이행): 비동기 작업이 성공적으로 완료되어 결과값이 반환된 상태입니다.
- Rejected(거부): 비동기 작업이 실패하거나 오류가 발생한 상태입니다.

4. _비동기 작업을 처리할 때, Callback과 Promise 중 어떤 방식을 선택해야 할까요? 어떤 요소들을 고려해야 할까요?_<br>

- 가독성: 콜백 헬(callback hell) 문제가 발생할 수 있는 콜백 방식은 가독성이 떨어질 수 있습니다. Promise나 Async/Await는 코드의 가독성을 향상시킬 수 있습니다.
- 에러 처리: Promise나 Async/Await은 에러 처리를 보다 쉽게 할 수 있습니다. 에러 핸들링이 중요한 경우에는 Promise나 Async/Await을 고려하는 것이 좋습니다.
- 기존 코드와의 호환성: 기존에 콜백 방식으로 작성된 코드와의 호환성을 고려해야 할 수 있습니다. 기존 코드와의 통합이 필요한 경우에는 콜백 방식을 유지하는 것이 좋을 수도 있습니다.

## 34. 자바스크립트와 타언어의 차이점

- 실행 환경: 자바스크립트는 주로 웹 브라우저에서 실행되며, 다른 언어들은 특정 운영 체제나 플랫폼에서 실행됩니다.
- 타입 시스템: 자바스크립트는 동적 타입 언어로, 변수의 타입을 런타임 시에 결정합니다. 다른 언어들은 정적 타입 언어로, 변수의 타입을 컴파일 시에 결정합니다.
- 문법과 구문: 자바스크립트의 문법과 구문은 C 언어를 기반으로 하고 있습니다. 다른 언어들은 각자의 문법과 구문을 가지고 있습니다.
- 생태계와 라이브러리: 자바스크립트는 다양한 생태계와 라이브러리를 가지고 있어 웹 개발에 많이 사용됩니다. 다른 언어들도 각자의 생태계와 라이브러리를 가지고 있습니다.
- 사용 목적: 자바스크립트는 주로 웹 프론트엔드 개발에 사용되며, 다른 언어들은 특정 분야나 플랫폼에서 사용됩니다.

예상질문 <br>
->

1. _자바스크립트는 동적 타입 언어로 변수의 타입을 런타임 시에 결정합니다. 이러한 특성이 자바스크립트의 장점이 될 수 있을까요? 혹은 어떠한 단점이 있을 수 있을까요?_<br><br>
   장점으론 <br>

- 빠른 프로토타이핑: 타입 선언에 대한 제약이 적어서 빠른 개발 및 실험이 가능합니다.
- 유연한 데이터 구조: 변수의 타입을 동적으로 변경할 수 있어 다양한 데이터 구조를 쉽게 다룰 수 있습니다.
- 자유로운 확장성: 객체의 속성을 동적으로 추가하거나 변경할 수 있어 유연한 확장이 가능합니다.<br><br>하지만 동적 타입 언어의 단점으로는 타입 에러가 런타임 시에 발생할 수 있다는 점과 코드의 가독성과 유지보수의 어려움이 있을 수 있습니다.

2. _자바스크립트는 C 언어를 기반으로 한 문법과 구문을 가지고 있습니다. 이러한 유사성이 자바스크립트의 개발자들에게 어떤 이점을 제공할 수 있을까요?_<br>

- 쉬운 학습 곡선: C 언어와 유사한 문법을 가지고 있기 때문에 C나 C++ 등의 언어를 이미 알고 있는 개발자들에게 자바스크립트를 학습하기 쉽습니다.
- 코드 재사용: C 언어와 유사한 문법을 가지므로 이미 작성된 C 언어의 코드를 일부 수정하여 자바스크립트로 재사용할 수 있습니다.

3. _다른 언어들이 특정 분야나 플랫폼에서 주로 사용되는 반면, 자바스크립트는 주로 웹 프론트엔드 개발에 사용됩니다. 이에 대한 이유는 무엇일까요? 자바스크립트를 웹 개발 이외의 다른 분야에서도 사용할 수 있는 방법은 있을까요?_<br>

- 웹 브라우저에서 기본적으로 자바스크립트를 실행할 수 있는 환경이 구축되어 있습니다.
- 동적인 웹 페이지와 사용자 인터랙션을 구현하는 데 자바스크립트가 적합합니다.
- 다양한 라이브러리와 프레임워크가 존재하여 웹 개발을 더욱 편리하게 할 수 있습니다.<br><br>
  그러나 자바스크립트는 Node.js와 같은 환경을 통해 서버 사이드 개발이 가능하며, 모바일 애플리케이션 개발에도 활용할 수 있습니다.

4. _자바스크립트의 생태계와 라이브러리는 웹 개발에 많은 지원을 제공합니다. 어떤 자바스크립트 라이브러리들이 인기가 있고 어떤 상황에서 사용될 수 있을까요?_<br>

- React: 웹 프론트엔드 개발에 사용되는 UI 라이브러리로, 컴포넌트 기반 개발을 지원하고 가상 DOM을 활용하여 효율적인 렌더링을 제공합니다.

- Vue.js: 웹 프론트엔드 개발에 사용되는 프레임워크로, 가볍고 직관적인 문법을 가지고 있어 빠르게 학습할 수 있습니다.
- Angular: 웹 애플리케이션 개발에 사용되는 프레임워크로, TypeScript를 기반으로 하며 전체적인 개발 환경을 제공합니다.

- jQuery: 자바스크립트의 인기 있는 라이브러리로, 웹 페이지의 DOM 조작과 이벤트 처리를 간편하게 할 수 있도록 도와줍니다.

- Express.js: Node.js를 위한 웹 애플리케이션 프레임워크로, 간결하고 유연한 구조를 가지고 있어 웹 서버 개발을 쉽게 할 수 있습니다.

## 35. ES6의 호환성 해결방법은?

ES6의 호환성을 해결하기 위해 주로 사용되는 두가지 방법 으로

1. 트랜스파일링: Babel과 같은 도구를 사용하여 ES6 코드를 이전 버전의 JavaScript로 변환합니다. 이를 통해 모든 브라우저에서 호환되는 코드로 변환할 수 있습니다.
2. 폴리필 사용: 폴리필은 ES6에서 추가된 새로운 기능을 이전 버전의 JavaScript에서도 사용할 수 있도록 구현한 코드입니다. 폴리필 라이브러리를 사용하여 필요한 폴리필을 추가합니다.

이러한 방법을 통해 ES6 코드를 다양한 브라우저에서 호환되는 형태로 변환하고 실행할 수 있습니다.

예상질문 <br>
->

1. _ES6 호환성을 해결하기 위해 트랜스파일링과 폴리필 사용 중 어떤 방법을 선호하고 그 이유는 무엇인가요?_<br><br>
   저는 일반적으로 트랜스파일링 방법을 선호합니다. 이는 ES6 코드를 이전 버전의 JavaScript로 변환하여 모든 브라우저에서 실행 가능하게 만들어주기 때문입니다. 트랜스파일링은 코드를 변환하는 과정에서 최적화를 수행할 수 있고, 원본 코드와 변환된 코드 사이의 일관성을 유지할 수 있습니다. 또한, 폴리필보다는 변환된 코드가 더 가볍고 빠를 수 있습니다.

2. _ES6의 특정한 기능을 지원하지 않는 브라우저에서 폴리필을 적용하면 어떤 문제가 발생할 수 있나요?_<br><br>
   폴리필은 ES6에서 추가된 새로운 기능을 이전 버전의 JavaScript에서 사용할 수 있도록 구현한 코드입니다. 그러나 특정한 기능을 완전히 대체하기 어려울 수도 있고, 폴리필 자체가 추가적인 코드로 인해 번거로울 수 있습니다. 또한, 모든 브라우저에서 동작을 보장하기 위해 필요한 폴리필을 추가해야 하므로 파일 크기가 커질 수 있고, 이는 초기 로딩 속도를 저하시킬 수 있습니다.

3. _트랜스파일링을 사용할 때 코드 크기와 성능에 어떤 영향을 미칠 수 있을까요?_<br><br>
   트랜스파일링은 ES6 코드를 이전 버전의 JavaScript로 변환하는 과정이므로, 변환된 코드의 크기는 일반적으로 원본 코드보다 크게 됩니다. 이는 파일 다운로드 시간과 초기 로딩 속도에 영향을 줄 수 있습니다. 그러나 트랜스파일러(Babel 등)는 코드를 최적화하고 불필요한 부분을 제거하여 성능을 향상시킬 수도 있습니다.

4. _ES6 호환성을 고려할 때 더 효율적이고 안정적인 접근 방법이 있는지 알려주세요._<br><br>
   트랜스파일링과 폴리필을 함께 사용하여 ES6 코드를 변환하고 필요한 폴리필을 추가하는 방법입니다. 이 방법은 최신 기능을 사용하면서도 대상 브라우저의 호환성을 유지할 수 있습니다. Babel과 같은 도구를 사용하여 트랜스파일링하고, 필요한 폴리필 라이브러리를 선택적으로 추가하여 사용하면 됩니다.

## 36. babel은 컴파일러 인가? 트랜스파일러인가?

Babel은 트랜스파일러입니다.

트랜스파일러는 소스 코드를 한 프로그래밍 언어에서 다른 언어로 변환하는 도구를 말합니다. Babel은 주로 최신 버전의 JavaScript인 ES6 (ES2015) 이상의 코드를 이전 버전의 JavaScript로 변환하는 데 사용됩니다.

예상질문 <br>
->

1. _Babel이 왜 필요한가요?_<br><br>
   Babel은 최신 버전의 JavaScript를 이전 버전으로 변환하여 다양한 브라우저 및 환경에서 호환성을 확보하기 위해 사용됩니다. 즉, 다양한 JavaScript 기능과 문법을 사용하고 싶지만 모든 브라우저에서 지원되지 않는 경우에 Babel을 사용하여 호환성을 유지할 수 있습니다.

2. _Babel의 주요 기능은 무엇인가요?_<br><br>
   Babel은 주로 두 가지 기능을 제공합니다. 첫째, 구문 변환(Syntax transformation) 기능으로, 최신 JavaScript 문법을 이전 버전의 JavaScript로 변환합니다. 이를 통해 브라우저가 이해할 수 있는 코드로 변환됩니다. 둘째, 폴리필(polyfill) 기능으로, 최신 JavaScript 메서드나 함수를 이전 버전의 JavaScript에서도 사용할 수 있도록 지원합니다.

3. _Babel을 사용하여 ES6 이상의 코드를 이전 버전으로 변환할 때 주의해야 할 점은 무엇인가요?_<br><br>
   주의해야 할 점은 Babel은 코드를 변환하는 도구이지만, 모든 기능을 100% 이전 버전과 동일하게 변환하는 것은 아닙니다. 따라서, 특정 JavaScript 기능이나 라이브러리에서 지원되는 최소 버전을 확인하고, Babel의 플러그인이나 프리셋 설정을 적절히 선택해야 합니다. 또한, 변환된 코드의 동작을 테스트하여 예상한 대로 작동하는지 확인하는 것이 중요합니다.

## 37. ES6에 추가된 것은 무엇인가?

1. **`let`** 및 **`const`** 키워드: 블록 스코프 변수를 선언하기 위해 **`var`** 대신 **`let`**과 **`const`**를 사용할 수 있습니다.
2. Arrow 함수: 더 간결한 함수 표현을 제공하는 화살표 함수 문법을 도입했습니다.
3. 클래스: 객체지향 프로그래밍을 위한 클래스 문법이 추가되었습니다.
4. 모듈: 모듈화를 위한 **`import`** 및 **`export`** 문법이 도입되었습니다.
5. 템플릿 리터럴: 더 편리한 문자열 조합을 위해 템플릿 리터럴 문법을 도입했습니다.
6. 확장된 객체 리터럴: 객체 생성 및 속성 정의를 더 간결하게 할 수 있는 문법을 도입했습니다.
7. 분해 할당(Destructuring assignment): 배열이나 객체에서 필요한 값들을 추출하여 변수에 할당하는 문법을 도입했습니다.
8. Promise: 비동기 작업의 처리를 위한 Promise 객체를 도입했습니다.
9. 화살표 함수: 함수를 더 간결하게 정의할 수 있는 화살표 함수 문법을 도입했습니다.
10. 기타: **`for...of`** 반복문, 기본 매개변수(Default parameters), 전개 연산자(Spread operator) 등 다양한 기능들이 추가되었습니다.

예상질문<br>
->

1. _ES6의 주요 기능들 중 어떤 것이 가장 흥미로웠나요? 그 이유는 무엇인가요?_<br><br>
   저는 화살표 함수(Arrow functions)와 모듈(Module)이 가장 흥미로웠습니다. 화살표 함수는 더 간결한 함수 표현을 제공하고, this의 동작 방식도 더 직관적이어서 코드를 읽고 이해하기 쉬워집니다. 모듈은 코드를 논리적인 단위로 나누어 관리할 수 있으며, 재사용성과 유지보수성을 향상시킬 수 있습니다.

2. _ES6의 화살표 함수를 사용하면서 어떤 장점을 경험했나요? 어떤 상황에서 주로 화살표 함수를 사용하시나요?_<br><br>
   화살표 함수를 사용하면 함수 정의가 간결해지고, this의 동작이 더 명확해지는 장점을 경험했습니다. 특히, 콜백 함수나 간단한 함수 표현에서 많이 활용합니다. 예를 들어, 배열의 각 요소에 대해 작업을 수행하는 경우에 화살표 함수를 자주 사용합니다.

3. _ES6의 클래스 문법을 사용해 본 적이 있나요? 클래스를 사용하여 객체지향 프로그래밍을 어떻게 구현하는지 설명해주세요._<br><br>
   네, ES6의 클래스 문법을 사용해 본 적이 있습니다. 클래스를 사용하여 객체지향 프로그래밍을 구현할 때, 클래스는 객체의 설계도와 같은 역할을 합니다. 클래스를 정의하고 클래스 내에서 속성과 메서드를 선언하여 객체를 생성하고 조작할 수 있습니다. 이를 통해 코드를 모듈화하고 재사용성을 높일 수 있으며, 상속을 통해 다형성을 구현할 수도 있습니다.

4. _Promise 객체에 대해 어떤 경험이나 사용 사례가 있나요? 비동기 작업을 처리할 때 Promise를 어떻게 활용하셨나요?_<br><br>
   제가 개발한 웹 애플리케이션에서 API와의 비동기 통신을 처리할 때 Promise를 활용한 경험이 있습니다. Promise는 비동기 작업의 성공 또는 실패를 처리하기 위한 객체로, 비동기 작업이 완료되면 resolve 또는 reject 함수를 호출하여 상태를 변경합니다. 이를 활용하여 API 요청을 보내고 응답을 받은 후 적절한 처리를 할 수 있었습니다.

## 38. Context API란?

Context API는 React 라이브러리에서 제공하는 상태 관리 기능입니다. Context API를 사용하면 상위 컴포넌트에서 하위 컴포넌트로 데이터를 전달할 수 있으며, 컴포넌트 간에 전역적으로 상태를 공유할 수 있습니다.

Context API를 사용하면 여러 컴포넌트에서 공유되는 상태를 쉽게 관리할 수 있으며, 복잡한 컴포넌트 구조에서도 데이터를 효율적으로 전달할 수 있습니다.

예상질문<br>
->

1. _Context API를 사용하는 상황과 예시를 좀 더 구체적으로 설명해볼 수 있을까요?_<br>

- 사용자 인증 정보: 로그인 상태와 관련된 정보를 한 번에 관리하고 여러 컴포넌트에서 접근할 수 있습니다.
- 테마 설정: 사용자가 선택한 테마 정보를 한 곳에서 관리하고, 컴포넌트 간에 테마를 전달하여 일관된 디자인을 유지할 수 있습니다.
- 언어 설정: 다국어 지원을 위해 언어 설정을 한 곳에서 관리하고, 컴포넌트들이 해당 설정을 사용할 수 있습니다.

2. _Context API를 사용하는 것과 상태 관리 라이브러리인 Redux를 사용하는 것의 차이점은 무엇인가요?_<br>

- 규모와 복잡도: Context API는 상태 관리를 위한 간단한 기능을 제공하는 반면, Redux는 복잡하고 대규모 애플리케이션에서 상태 관리를 위한 풍부한 기능을 제공합니다.
- 생태계와 도구: Redux는 더 많은 생태계와 다양한 개발 도구를 가지고 있으며, 중앙화된 상태 관리를 위한 정형화된 패턴을 제공합니다. Context API는 React 자체의 일부이며, Redux에 비해 생태계와 도구는 제한적입니다.
- 성능: Redux는 상태 변화를 추적하여 최적화된 업데이트를 수행하는 반면, Context API는 업데이트 시점을 더 넓게 설정하므로 성능 면에서 Redux가 더 효율적일 수 있습니다.

3. _Context API를 사용할 때 주의해야 할 점이나 잠재적인 문제점은 무엇인가요?_<br>

- Context API를 남용하면 컴포넌트 트리의 깊은 곳까지 데이터가 전파되어 성능 저하를 일으킬 수 있습니다. 필요한 컴포넌트에서만 사용하는 것이 좋습니다.
- Context 객체를 너무 많이 생성하면 메모리 사용량이 증가할 수 있습니다. 필요한 경우에만 생성하고 재사용하는 것이 좋습니다.
- Context 객체를 직접 수정하면 컴포넌트 업데이트가 제대로 동작하지 않을 수 있습니다. 불변성을 유지하고, 변경 시에는 새로운 객체를 생성하여 전달해야 합니다.

## 39. 라이프사이클 메소드에 대해 설명

라이프사이클 메소드는 React 컴포넌트의 생명주기 동안 호출되는 메소드로, 컴포넌트의 생성, 업데이트, 소멸 시에 특정 작업을 수행할 수 있습니다. **`componentDidMount`**은 컴포넌트가 렌더링된 후에 호출되며 초기화 작업에 사용됩니다. **`componentDidUpdate`**는 컴포넌트가 업데이트된 후에 호출되며 업데이트 작업에 사용됩니다. **`componentWillUnmount`**는 컴포넌트가 소멸되기 직전에 호출되며 정리 작업에 사용됩니다.
예상질문 <br>
->

1. _컴포넌트의 라이프사이클을 사용할 때 어떤 상황에서 주로 활용되는지 예시를 들어 설명해주세요._<br>

- 컴포넌트가 초기화되거나 업데이트될 때 특정 작업을 수행해야 할 때
- 외부 데이터를 불러오거나 구독하고, 컴포넌트 소멸 시에 정리해야 할 때
- 컴포넌트의 렌더링 전후에 DOM 조작이 필요한 경우

2. _라이프사이클 메소드보다 더 권장되는 방식이 있는지 알려주세요._<br><br>
   React 16.3 이후부터는 라이프사이클 메소드 대신 React 훅(Hook)을 사용하는 것이 권장됩니다. 훅은 함수형 컴포넌트에서 상태 관리와 라이프사이클 기능을 제공하는 방식입니다.

3. _useEffect 훅이 라이프사이클 메소드와 어떻게 다른지 설명해주세요._<br><br>
   useEffect 훅은 라이프사이클 메소드와 다른 방식으로 동작합니다. useEffect는 컴포넌트의 렌더링 결과가 실제 DOM에 반영된 후에 호출되며, 컴포넌트의 props나 state가 업데이트되어 재렌더링되더라도 호출됩니다. 이를 통해 더 유연하게 컴포넌트의 작업을 관리할 수 있습니다. 또한, useEffect는 여러 개 사용될 수 있고, 특정 의존성을 갖는 작업만을 수행할 수 있습니다.

## 40. react 클래스형과 함수형의 차이

React에서 클래스형 컴포넌트와 함수형 컴포넌트는 두 가지 주요한 형태의 컴포넌트 작성 방식입니다.

클래스형 컴포넌트는 ES6의 클래스 문법을 사용하여 정의되며, **`React.Component`**를 상속받아 컴포넌트를 생성합니다. 클래스형 컴포넌트는 **`render()`** 메서드를 포함하여 컴포넌트의 렌더링을 처리하고, 내부적으로 상태(State)와 생명주기 메서드(Lifecycle methods)를 관리할 수 있습니다.

반면, 함수형 컴포넌트는 JavaScript의 함수로 컴포넌트를 정의합니다. 최근에는 React Hooks라는 기능이 도입되면서 함수형 컴포넌트에서도 상태(State)와 생명주기와 관련된 작업을 할 수 있게 되었습니다. 함수형 컴포넌트는 보다 간결하고 가독성이 좋으며, 컴포넌트 간의 재사용성이 높아집니다.

정리하면 클래스형 컴포넌트는 클래스 문법을 사용하고, 상태(State)와 생명주기 메서드를 관리할 수 있습니다. 함수형 컴포넌트는 함수로 정의되며, 최근에는 React Hooks를 사용하여 상태와 생명주기를 다룰 수 있습니다. 함수형 컴포넌트는 간결하고 가독성이 좋으며, 재사용성이 높습니다. 최신의 React에서는 함수형 컴포넌트를 주로 사용하고 있습니다.
예상질문 <br>
->

1. _함수형 컴포넌트와 클래스형 컴포넌트의 선택 기준은 무엇인가요?_<br><br>
   함수형 컴포넌트는 간결하고 가독성이 좋으며, Hooks를 통해 상태와 생명주기를 다룰 수 있기 때문에 대부분의 상황에서 권장됩니다. 함수형 컴포넌트는 순수 함수로 작성되기 때문에 테스트와 재사용성 측면에서도 이점을 가집니다.<br>
   하지만 클래스형 컴포넌트는 Hooks가 도입되기 이전에 주로 사용되었으며, 일부 라이브러리나 프로젝트 구조가 클래스형 컴포넌트를 선호하는 경우가 있을 수 있습니다. 또한, 클래스형 컴포넌트는 더 복잡한 상태 관리나 생명주기 로직이 필요한 경우에 유용할 수 있습니다.

2. _함수형 컴포넌트를 사용할 때 어떤 장점이 있나요?_<br><br>
   함수형 컴포넌트는 코드의 간결성과 가독성을 높여줍니다. 또한, Hooks를 사용하여 상태와 생명주기를 다룰 수 있어 클래스형 컴포넌트보다 더 간단하고 직관적인 방식으로 상태 관리를 할 수 있습니다. 함수형 컴포넌트는 순수 함수로 작성되기 때문에 테스트하기 쉽고, 재사용성이 높아 코드의 유지보수와 개발 생산성을 향상시킵니다.

3. _클래스형 컴포넌트를 사용해야 하는 특정한 상황이 있을까요?_<br><br>
   클래스형 컴포넌트는 Hooks가 도입되기 이전에 사용되었으며, 일부 라이브러리나 프로젝트 구조에서 여전히 클래스형 컴포넌트를 선호하는 경우가 있습니다. 또한, 클래스형 컴포넌트는 더 복잡한 상태 관리나 생명주기 로직이 필요한 경우에 유용할 수 있습니다. 예를 들어, 컴포넌트가 상태를 많이 가지고 있거나, 리액트의 라이프사이클 메소드를 활용해야 하는 경우에는 클래스형 컴포넌트가 적합할 수 있습니다.

4. _함수형 컴포넌트에서 상태(State)와 생명주기를 다루는 방법은 어떤 것이 있나요?_<br><br>
   함수형 컴포넌트에서 상태(State)와 생명주기를 다루기 위해 React Hooks가 도입되었습니다. Hooks는 함수형 컴포넌트에서 상태 관리와 생명주기와 관련된 작업을 수행할 수 있는 함수를 제공합니다.
