## 21. GET,POST 방식의 차이점

GET은 서버로부터 데이터를 요청하고 가져오는 메소드입니다. 주로 데이터 조회에 사용됩니다. 데이터가 URL에 노출되고 캐싱이 가능합니다.

POST는 서버에 새로운 데이터를 생성하거나 업데이트하는 메소드입니다. 데이터를 요청 본문에 담아 전송하며, 보안성이 더 높고 캐싱되지 않습니다. 주로 데이터 생성 또는 업데이트에 사용됩니다.

## POST 요청에서 보안성이 더 높다고 했는데, 왜 그런지 설명해주세요.

get 요청의경우 쿼리파라미터에 세팅되어 url이 노출되어 요청되지만, post 요청은 요청 body에 세팅되어 요청되기 때문에 본문내용이 노출되지 않아 보안성이 높습니다.
But! HTTPS를 통한 암호화된 연결을 사용하는 경우, GET 요청이나 POST 요청 모두 안전한 방식으로 데이터를 전송할 수 있습니다.

## GET 요청에서 캐싱이 가능하다고 했는데, 어떻게 캐싱을 구현할 수 있을까요?

헤더에 Cache-Control, Expires, Last-Modified, ETag 같은 헤더를 사용하여 적절한 헤더를 응답에 포함시켜야 됩니다.

1.Cache-Control: 이 헤더는 캐시 동작을 제어합니다. 일반적으로 Cache-Control 헤더를 사용하여 캐싱을 활성화하거나 비활성화하고, 캐시의 유효기간을 설정하거나 캐시를 갱신하는 방법을 지정할 수 있습니다. 주요 값으로는 public, private, no-cache, max-age 등이 있습니다.

2.Expires: 이 헤더는 캐시의 만료 일자를 지정합니다. Expires 헤더는 유효한 날짜와 시간을 지정하여 클라이언트에게 캐시의 유효 기간을 알려줍니다. 이 헤더는 오래된 방식으로, Cache-Control 헤더와 함께 사용하는 것이 권장됩니다.

3.Last-Modified: 이 헤더는 서버에서 응답으로 보내는 리소스의 마지막 수정 날짜와 시간을 나타냅니다. 클라이언트는 이 헤더를 사용하여 리소스가 변경되었는지 확인하고, 변경되지 않은 경우 로컬 캐시를 사용할 수 있습니다.

4.ETag: 이 헤더는 리소스의 고유한 태그를 나타냅니다. 서버는 리소스의 내용이 변경되었을 때 ETag 값을 갱신합니다. 클라이언트는 서버에 저장된 ETag 값과 요청 시 전송된 ETag 값을 비교하여 리소스의 변경 여부를 확인하고, 변경되지 않은 경우 로컬 캐시를 사용할 수 있습니다.

캐싱이란?
캐싱(Caching)은 주어진 리소스의 복사본을 저장하고 있다가 요청 시에 서버로부터 리소스를 다시 다운받지 않고 해당 복사본을 반환하는 기술이다. 이를 활용하면 서버의 부하를 완화하고, 리소스가 클라이언트에 더 가깝게 존재하므로 회신에 더 적은 시간이 소요되어 성능이 향상될 수 있다. HTTP 캐싱에서는 일반적으로 GET에 대한 응답을 캐싱한다.

## GET과 POST의 차이점 이외에도 put patch의 차이점을 말해주세요

put: 리소스를 전송하여 업데이트하는 데 사용합니다. 기존의 리소스가 있는경우 기존의 데이터에 새로운 데이터로 덮어 씌우므로 주로 put이 아닌 patch메서드를 쓰는것을 권장하고 있습니다.

PATCH:: PATCH 메소드는 리소스의 부분적인 업데이트를 위해 사용됩니다.리소스의 일부만 업데이트하며, 클라이언트가 전송한 데이터로 리소스의 특정 필드를 수정합니다. 요청된 리소스가 이미 존재한다면, 클라이언트가 제공한 데이터로 해당 리소스의 일부를 변경합니다.

## 22. webpack 써보신 적 있나요?

네, webpack은 프론트엔드 개발에서 모듈 번들링을 도와주는 도구입니다. 여러 개의 자바스크립트 파일과 관련 리소스들을 하나로 묶어서 네트워크 요청 수를 줄이고 개발자들에게 모듈 시스템과 다양한 로더 및 플러그인 기능을 제공합니다. 프로젝트의 모듈화와 번들링에 유용하게 사용할 수 있는 도구입니다.

## 번들링은 무엇인가요?

번들링이란 모듈들의 의존성 관계를 파악하여 그룹화시켜주는 작업을 뜻합니다.즉, 분리된 녀석들을 하나로 합쳐주는 역할을 합니다.

## 번들링을 하는 이유는 무엇인가요?

1. 파일의 크기 문제 해결

번들 파일은 번들링을 거치지 않은 원본 프로그램 파일보다 크기가 작아지고 실행 속도, 로딩 속도 또한 빨라진다. 번들링을 하는 것은 성능 측면에서 무조건 이득입니다.

2. 애플리케이션 임의 조작 방지
   압축한 파일을 받아와 압축해제 전까지는 파일을 조작할 수 없는 것처럼, 번들링된 웹 애플리케이션도 사용자가 임의로 조작할 수 없다. 번들링되지 않은 원본 코드에 사용자가 접근할 수 있다면, 컴퓨터를 잘 아는 사용자가 이를 원하는 대로 조작할 위험이 생깁니다.

3. 파일 단위의 js 모듈 관리의 필요성
   변수를 중복 선언하거나 의도치 않은 값을 할당해 생기는 에러를 번들링 도구인 Webpack에서는 모듈 번들링으로 해결

## 모듈화는 무엇인가요?

소프트웨어의 성능을 향상시키거나 시스템의 디버깅, 시험, 통합 및 수정을 용이하도록 하는 소프트웨어 설계 기법 입니다.

## 23. 쿠키, 세션, 웹스토리지의 차이를 설명해보세요.

쿠키의 경우는 방문자의 정보를 방문자 컴퓨터의 메모리에 저장하는 것을 말한다. 세션은 방문자의 요청에 따른 정보를 방문자 메모리에 저장하는 것이 아닌 웹 서버가 세션 아이디 파일을 만들어 서비스가 돌아가고 있는 서버에 저장을 하는것을 말한다. 웹 스토리지는 클라이언트 측에 데이터를 저장하는 메커니즘입니다. 쿠키는 클라이언트로 전송되고 서버에서 사용될 수 있으며, 세션은 서버에 저장되어 클라이언트에 대한 상태를 유지합니다. 웹 스토리지는 브라우저 내에서 데이터를 저장하고 사용할 수 있는 기능을 제공합니다.
=> 내용 살짝 수정했습니당

## 쿠키와 세션의 차이점은 무엇인가요?

쿠키: 사용자에 의해 조작되어도 크게 문제되지 않을 인증정보를 브라우저에 저장함
세션: 인증에 대한 정보를 서버가 저장한다.

## 쿠키의 동작 방식을 설명해주세요.

1. 서버에서 클라이언트로 쿠키 전송: 웹 서버는 HTTP 응답 헤더에 "Set-Cookie"라는 헤더 필드를 추가하여 클라이언트로 쿠키를 전송합니다. 이 헤더에는 쿠키의 이름, 값, 속성 등이 포함됩니다.

2. 클라이언트에서 쿠키 저장: 클라이언트(일반적으로 웹 브라우저)는 쿠키를 받으면 이를 자동으로 저장합니다. 쿠키는 클라이언트의 로컬 파일 시스템에 저장되며, 도메인 및 경로와 연결됩니다.

3. 클라이언트에서 서버로 쿠키 전송: 클라이언트는 이후 서버로 요청을 보낼 때 HTTP 요청 헤더에 "Cookie"라는 헤더 필드를 추가하여 쿠키를 서버로 전송합니다. 이를 통해 서버는 클라이언트를 식별하고 이전 요청과 관련된 쿠키 정보를 활용할 수 있습니다.

4. 서버에서 쿠키 처리: 서버는 클라이언트로부터 전송된 쿠키를 수신하고, 해당 쿠키의 값과 속성을 확인하여 요청을 처리합니다. 서버는 쿠키를 사용하여 세션 관리, 사용자 인증, 사용자 설정 등을 구현할 수 있습니다.

5. 쿠키의 유효 기간과 속성: 쿠키에는 유효 기간(Expires)이나 만료 시간(Max-Age)을 설정할 수 있으며, 도메인(Domain)과 경로(Path)를 지정하여 쿠키의 범위를 제한할 수 있습니다. 또한, 보안 속성인 Secure 쿠키와 HttpOnly 쿠키를 사용하여 쿠키의 보안성을 강화할 수 있습니다.

## 세션은 어떻게 동작하나요?

HTTP Session 동작 순서

1. 클라이언트(사용자)가 서버로 접속(http 요청)을 시도한다.

2. 서버(웹)는 접근한 클라이언트의 request-header field인 cookie를 확인해 클라이언트가 해당 session-id를 보내왔는지 확인한다.

3. 만약 클라이언트로 부터 발송된 session-id가 없다면, 서버는 session-id를 생성해 클라이언트에게 response-header field인 set-cookie 값으로 session-id(임의의 긴 문자열)를 발행(응답)한다.

## 24. 동기와 비동기의 차이

동기(Synchronous)와 비동기(Asynchronous)는 작업의 처리 방식을 나타냅니다. 동기 작업은 순차적으로 진행되며, 이전 작업이 완료될 때까지 다음 작업을 실행하지 않습니다. 비동기 작업은 작업을 시작한 후에도 다음 작업을 바로 실행하며, 작업이 완료되는 시점에 결과를 처리합니다.

## 비동기 작업의 특징은?

1.  ajax, 이벤트 리스너, setTimeout작업을 실행할때 비동기적으로 동작한다.
2.  동시성(Concurrency): 비동기 작업은 다른 작업과 동시에 실행될 수 있습니다. 이는 여러 작업을 병렬로 처리하고, 작업이 완료될 때까지 다른 작업을 기다리지 않아도 되는 이점을 제공합니다.

3.  비차단(Non-blocking): 비동기 작업은 작업이 완료되기를 기다리지 않고 다음 코드로 진행될 수 있습니다. 이로 인해 다른 작업을 수행하거나 대기 중인 작업을 처리할 수 있으며, 전체 시스템의 응답성을 향상시킵니다.

4.  콜백(Callback) 또는 프라미스(Promise): 비동기 작업은 콜백 함수나 프라미스를 통해 작업이 완료되면 실행할 코드를 지정할 수 있습니다. 이를 통해 비동기 작업의 결과를 처리하거나 오류를 처리하는 등의 후속 작업을 수행할 수 있습니다.

5.  이벤트 기반(Event-driven): 비동기 작업은 이벤트 기반의 시스템에서 자주 사용됩니다. 작업의 완료나 오류 등의 이벤트가 발생하면, 해당 이벤트를 처리하기 위한 코드가 실행됩니다.

6.  병렬성(Parallelism): 비동기 작업은 병렬 처리를 통해 시스템 자원을 효율적으로 활용할 수 있습니다. 여러 작업을 동시에 실행하여 전체 작업의 처리 속도를 향상시킬 수 있습니다.

7.  오버헤드: 비동기 작업은 추가적인 관리 비용과 동기화 오버헤드를 초래할 수 있습니다. 작업의 상태 추적, 동기화 및 에러 핸들링에 관련된 추가 코드 작성이 필요할 수 있습니다.

## 25. Array vs LinkedList

Array는 데이터를 연속된 메모리 공간에 저장하는 자료구조이고, LinkedList는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 연결된 자료구조입니다
Array는 빠른 접근이 필요하거나 데이터의 크기가 변경되지 않는 경우에 유리하고, LinkedList는 데이터의 삽입과 삭제가 빈번하거나 크기가 동적으로 변하는 경우에 유리합니다. 선택은 사용하고자 하는 기능과 데이터의 특성에 따라 달라집니다.

```
배열 => 정해져있는 메모리를 사용해서 낭비심함 o(1)
linkedlist => 각 요소는 자신의 데이터와 다음 요소를 가리키는 포인터(링크)로 구성됩니다.
임의의 요소에 접근하기 위해서는 처음부터 순차적으로 접근해야 하므로 시간 복잡도가 O(n)
```

## 배열과 linkedlist는 각각 컴퓨터 프로세스의 메모리 구조에서 어디에 들어가나요?

둘다 queue에 저장됩니다. 배열은 연속된 메모리에 할당되는 반면, 연결 리스트는 동적으로 할당되어 메모리의 불연속적인 영역에 저장됩니다.

## 26. 서버 사이드 렌더링이란?

서버 사이드 렌더링은 웹 애플리케이션의 초기 렌더링을 서버에서 처리하는 방식으로, 초기 로딩 속도 개선과 SEO에 유리합니다. 서버에서 HTML을 렌더링하여 클라이언트에 전달하고, 클라이언트에서는 추가적인 동작을 처리합니다. 이는 SPA의 초기 로딩 속도와 SEO 문제를 해결하기 위한 방법입니다.

## csr과 ssr의 차이점은?

1. 렌더링 위치:
   CSR: 클라이언트(브라우저)에서 렌더링이 수행됩니다. 초기 페이지 로드 시에는 빈 HTML을 전송하고, 클라이언트에서 JavaScript를 사용하여 데이터를 요청하고 렌더링합니다.
   SSR: 서버에서 렌더링이 수행됩니다. 초기 페이지 로드 시에 서버에서 데이터를 가져와 HTML을 완전한 상태로 전송하고, 클라이언트는 추가적인 렌더링 과정 없이 화면을 표시합니다.

2. 초기 로딩 속도:
   CSR: 초기 페이지 로드 시에는 빈 HTML이 전송되고, 필요한 데이터 및 JavaScript 파일을 다운로드하고 실행해야 합니다. 초기 로딩 속도가 느릴 수 있습니다.
   SSR: 초기 페이지 로드 시에 서버에서 완전한 HTML이 전송되기 때문에 초기 로딩 속도가 빠릅니다. 사용자는 즉시 완전한 페이지를 볼 수 있습니다.

3. seo 대책:
   CSR: 초기 페이지 로드 시에는 빈 HTML이 전송되고, JavaScript를 사용하여 동적으로 콘텐츠를 렌더링하기 때문에 검색 엔진이 페이지를 색인하기 어려울 수 있습니다. 추가적인 SEO 대책이 필요할 수 있습니다.
   SSR: 서버에서 완전한 HTML이 전송되기 때문에 검색 엔진이 페이지를 쉽게 색인할 수 있습니다. SEO에 유리한 방식입니다.
4. 인터랙티브한 경험
   CSR: 클라이언트에서 데이터를 비동기적으로 요청하고 렌더링하기 때문에, 인터랙티브한 경험을 제공할 수 있습니다. SPA (Single-Page Application)에 적합합니다.
   SSR: 초기 페이지 로드 시에 완전한 HTML을 전송하기 때문에 인터랙티브한 경험이 제한될 수 있습니다. 전통적인 웹 애플리케이션에 적합합니다.

## 28. 아토믹 디자인 패턴에 대해 아는가?

아토믹 디자인 패턴은 웹 인터페이스 디자인을 구성하는 데 사용되는 방법론입니다. 이 패턴은 디자인 요소들을 작은 단위로 분해하여 구성 요소를 구조화하고 재사용 가능한 디자인 시스템을 구축합니다. 아토믹 디자인은 다양한 크기와 복잡성의 컴포넌트를 구성하여 일관성 있고 효율적인 디자인을 가능하게 합니다. 이 방식은 웹 애플리케이션의 개발 및 유지보수를 용이하게 하며, 디자인 시스템의 확장성과 일관성을 제공합니다.

## 아토믹 디자인의 단점은?

아토믹 디자인은 많은 수의 구성 요소로 이루어져 있으며, 각각의 요소가 다양한 상태와 속성을 가질 수 있습니다. 이는 디자인 및 개발 프로세스를 복잡하게 만들 수 있습니다. 디자인 시스템과 구성 요소의 관리 및 업데이트도 추가적인 작업을 요구할 수 있습니다.

## 29. 웹 스토리지의 차이점

웹 스토리지에는 두 가지 주요한 유형이 있습니다: 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)입니다.

-로컬 스토리지는 웹 애플리케이션에서 데이터를 영구적으로 저장하는 데 사용됩니다. 이는 사용자의 브라우저에 데이터를 유지하며, 브라우저를 종료하고 다시 시작해도 데이터가 유지됩니다.

-세션 스토리지는 로컬 스토리지와 비슷하지만, 브라우저 세션 동안만 데이터를 유지합니다. 사용자가 브라우저를 닫으면 세션 스토리지에 저장된 데이터는 삭제됩니다.

두 스토리지 모두 JavaScript를 사용하여 데이터를 저장하고 검색할 수 있습니다. 일반적으로 로컬 스토리지와 세션 스토리지는 간단하고 편리한 데이터 저장 솔루션을 제공하며, 브라우저 쿠키와 비교하여 더 많은 데이터를 저장할 수 있고 서버에 데이터를 전송하지 않아도 됩니다.

## 로컬스트리지와 세션스트리지는 어떨때 이용할수 있는가?

1. 세션

   - 로그인 상태 유지: 웹 사이트에서 로그인을 하면, 해당 사용자의 로그인 상태를 HTTP 세션을 사용하여 유지할 수 있습니다. 이를 위해 서버는 로그인 요청에 대한 인증을 수행하고, 인증이 완료되면 사용자 정보를 세션에 저장합니다. 이후 사용자가 웹 페이지를 요청할 때마다, 서버는 해당 세션에 저장된 정보를 확인하여 로그인 상태를 유지합니다.

   - 쇼핑 카트 기능 구현: 웹 사이트에서 쇼핑 카트 기능을 구현할 때도 HTTP 세션을 사용할 수 있습니다. 사용자가 상품을 장바구니에 담으면, 서버는 해당 사용자의 세션에 상품 정보를 저장합니다. 이후 사용자가 쇼핑 카트를 확인하거나 주문을 완료할 때마다, 서버는 해당 세션에 저장된 정보를 확인하여 쇼핑 카트 정보를 제공합니다.

   - 게시판에서 작성 중인 글 임시 저장: 웹 사이트에서 글을 작성할 때, 작성 중인 글을 임시로 저장하고 싶을 때 HTTP 세션을 사용할 수 있습니다. 사용자가 글을 작성하면, 서버는 해당 사용자의 세션에 작성 중인 글을 저장합니다. 이후 사용자가 다시 글 작성 페이지에 접속하면, 서버는 해당 세션에 저장된 글을 불러와서 사용자에게 제공합니다.

   2. 로컬스트리지

   - 사용자 설정 유지: 사용자가 웹 애플리케이션에서 설정한 환경 설정을 로컬 스토리지에 저장하여, 다음에 웹 앱을 열 때도 설정이 유지되도록 할 수 있습니다. 예를 들어, 언어 설정, 테마 설정, 글꼴 크기 등을 로컬 스토리지에 저장하여 사용자가 설정한 대로 웹 앱을 표시할 수 있습니다.

   - 사용자 로그인 정보 저장: 사용자의 로그인 정보(예: 사용자 이름, 토큰 등)을 로컬 스토리지에 저장하여, 웹 애플리케이션을 다시 열 때마다 사용자가 자동으로 로그인되도록 할 수 있습니다. 이를 통해 사용자는 매번 로그인 정보를 입력하지 않고도 웹 앱에 접근할 수 있습니다.

   - 캐시 데이터 저장: 웹 앱에서 빈번하게 사용되는 데이터나 API 요청 결과를 로컬 스토리지에 저장하여, 다음에 해당 데이터를 요청할 때 서버로부터 다시 받아오지 않고 로컬에서 바로 사용할 수 있습니다. 이를 통해 네트워크 요청을 줄이고 애플리케이션의 성능을 향상시킬 수 있습니다.

   - 오프라인 데이터 사용: 로컬 스토리지에 저장된 데이터를 사용하여 오프라인 상태에서도 웹 앱을 사용할 수 있습니다. 웹 앱이 오프라인 상태인 경우에도 로컬 스토리지에 저장된 데이터를 기반으로 콘텐츠를 표시하거나 작업을 수행할 수 있습니다.
