## 41. 타입스크립트란?

타입스크립트는 마이크로소프트에서 개발하였으며, 개발자들이 더 큰 규모의 프로젝트를 관리하고 유지보수하기 쉽도록 도와줍니다. 타입스크립트는 정적 타입 검사를 통해 코드의 안정성을 높이고, 개발자에게 타입 관련 오류를 사전에 포착하여 디버깅을 용이하게 합니다.

타입스크립트는 자바스크립트의 기능을 모두 포함하며, 추가로 타입 주석 및 타입 선언을 통해 변수, 함수, 객체 등에 타입을 명시할 수 있습니다. 이를 통해 변수의 타입 오류를 예방하고 코드 자동 완성, 정적 분석, 리팩토링 등의 기능을 제공받을 수 있습니다.

타입스크립트는 자바스크립트 개발자들에게 친숙한 문법과 생태계를 가지고 있으며, Angular와 같은 프레임워크에서 공식적으로 지원되고 있습니다. 또한 타입스크립트는 컴파일 단계에서 자바스크립트로 변환되므로, 모든 브라우저에서 실행 가능한 자바스크립트 코드로 변환됩니다.

타입스크립트는 대규모 프로젝트의 유지보수성을 향상시키고 타입 관련 오류를 사전에 예방하기 위해 많이 사용되고 있으며, 자바스크립트 생태계와 함께 성장하고 발전하고 있습니다.

예상질문 <br>
->

1. _타입스크립트에서 타입 관련 오류를 사전에 예방하고 안정성을 높이는 데 어떤 기능이 제공되나요?_<br><br>
   타입스크립트는 정적 타입 검사를 통해 타입 관련 오류를 사전에 예방하고 안정성을 높이는 기능을 제공합니다. 이를 위해 변수, 함수, 객체 등에 타입을 명시하고, 타입 검사기가 코드를 분석하여 타입 오류를 찾아내고 보고합니다. 타입 관련 오류를 사전에 예방하면 실행 시점에 발생할 수 있는 타입 관련 버그를 줄이고, 코드의 안정성을 높일 수 있습니다.

2. _타입스크립트의 정적 타입 검사는 어떻게 동작하며, 어떤 이점을 제공하나요?_<br><br>
   타입스크립트의 정적 타입 검사는 컴파일 단계에서 수행됩니다. 타입 검사기가 코드를 분석하여 변수 할당, 함수 호출, 프로퍼티 접근 등의 연산에서 타입 호환성을 검사합니다. 이를 통해 타입 오류를 사전에 찾아내고, 타입 불일치로 인한 잠재적인 버그를 예방할 수 있습니다. 정적 타입 검사는 컴파일 시간에 수행되므로, 런타임에 비해 빠르게 오류를 발견할 수 있고, 디버깅과 유지보수를 용이하게 해줍니다.

3. _타입스크립트의 컴파일 과정에서 어떻게 자바스크립트로 변환되는 건가요?_<br><br>
   타입스크립트는 자체적인 컴파일러를 사용하여 타입스크립트 코드를 자바스크립트로 변환합니다. 타입스크립트 컴파일러는 타입 주석과 타입 선언을 해석하고, 타입 검사를 수행한 뒤 자바스크립트 코드로 변환합니다. 변환된 자바스크립트 코드는 ES3, ES5, ES6 등의 특정 ECMAScript 버전으로 대상 환경에 맞춰 출력됩니다. 이후 변환된 자바스크립트 코드를 브라우저나 Node.js에서 실행할 수 있습니다.
4. _타입스크립트와 자바스크립트의 차이점과 장단점은 무엇인가요?_<br><br>
   타입스크립트와 자바스크립트의 가장 큰 차이점은 타입 시스템의 유무입니다. 자바스크립트는 동적 타입 언어로, 변수의 타입을 명시적으로 선언할 필요가 없습니다. 반면 타입스크립트는 정적 타입 언어로, 변수, 함수, 객체 등에 타입을 명시적으로 선언하고, 컴파일 단계에서 타입 검사를 수행합니다. 이를 통해 타입 관련 오류를 사전에 예방하고 안정성을 높일 수 있습니다.

## 42. angular와 react의 차이점

angular와 react 그리고 vue 모두 spa다
angular: 구글사에서 2010년 10월에 자바스크립트 기반의 오픈 소스 프론트엔드 웹 어플리케이션 프레임워크
Angular 2는 완전한 Typescript 를 바탕으로 개발을 해야함으로서 기존의 Angular 개발자들에게 당혹감을 주었다.
Angular 2는 기존의 AngularJS 의 코드와 호환이 안되며, AngularJS는 지원 종료되는 수순을 밟았다.
SSR 를 위한 기능들을 지원도 한다함

차이점: <br>1.데이터 바운딩 (양방향 바운딩)React 에서는 데이터가 위에서 아래로 흐른다. 즉 부모 컴포넌트에서 자식 컴포넌트에 props 를 흘리는 방식으로 단방향 데이터 바운딩이 이뤄진다. 그에 비해 Angular 에서는 데이터가 양방향으로 흐른다. 부모 컴포넌트에서 자식 컴포넌트로, 자식 컴포넌트에서 부모 컴포넌트로 데이터를 흘려 보낼 수 있다.<br>
2.React 는 컴포넌트 별로 가상 DOM 을 만들어 놓고 랜더링 시 새로운 가상 DOM 트리를 생성해 이전의 가상 DOM 과 어떤 차이가 있는지 비교 알고리즘을 통해서 비교 후 변경 사항이나, 새로운 추가 사항이 있을 시 이를 실제 DOM 에 반영하는 식으로 랜더링 한다. 이를 재조정 (Reconcilation) 이라고 하는데 React 에서는 재조정 과정을 하는데 있어서 Fiber 엔진을 사용한다. 즉 React 에서는 재조정 과정을 위해서는 메모리에 가상 DOM 을 두 개를 올려야 한다는 것이다. 반면에 angular의 Incremental DOM 방식은 랜더링 과정에서 변화를 감지하고 이를 DOM 트리에 반영하는 과정에 있어서 추가적인 메모리 공간을 요구하지 않는다. 랜더링 과정에서 변화를 감지하기 위해 실제 DOM 을 이용하며 변경 사항이 있을 시 이를 즉시 반영한다. Virtual DOM 을 활용할 때 보다 훨씬 메모리 관리에 있어서 효율적이다.
하지만! virtual 돔에 비해 느린면이 있다.

예상질문 <br>
->

1. _React의 단방향 데이터 바인딩과 Angular의 양방향 데이터 바인딩 각각의 장단점은 무엇인가요?_<br><br>
   React의 단방향 데이터 바인딩은 데이터의 흐름이 명확하고 예측 가능하며, 컴포넌트 간의 의존성이 낮아져 관리하기 쉽습니다. Angular의 양방향 데이터 바인딩은 데이터의 변화를 자동으로 감지하여 업데이트가 간편하지만, 복잡한 애플리케이션에서 데이터 흐름을 추적하기 어렵고 예상치 못한 부작용이 발생할 수 있습니다.
2. _React에서 가상 DOM과 Fiber 엔진을 사용하는 이유는 무엇인가요? 가상 DOM과 Fiber 엔진이 React의 성능에 어떤 영향을 미치나요?_<br><br>
   React의 가상 DOM과 Fiber 엔진은 빠른 랜더링과 성능 향상을 위해 사용됩니다. 가상 DOM은 실제 DOM과 비교하여 변경된 부분만 업데이트하므로 DOM 조작 횟수를 최소화하고 효율적인 랜더링을 가능하게 합니다. Fiber 엔진은 랜더링 작업을 작은 단위로 분할하여 우선순위를 부여하고, 중단 및 재개가 가능하게 해서 더 매끄러운 사용자 경험을 제공합니다.

3. _Angular의 Incremental DOM 방식이 React의 가상 DOM 방식보다 메모리 관리에 효율적이라고 설명했는데, 이에 대한 더 자세한 설명을 해주실 수 있나요?_<br><br>
   Angular의 Incremental DOM 방식은 실제 DOM을 직접 조작하므로 메모리에 가상 DOM을 저장하지 않아도 됩니다. 변경 사항이 발생하면 바로 반영되어 메모리 관리에 효율적입니다. 이는 작은 규모의 애플리케이션에서는 가벼운 장점을 가지지만, 대규모 프로젝트에서는 가상 DOM 방식에 비해 성능 면에서 약간의 차이가 있을 수 있습니다.

4. _React의 가상 DOM 방식과 Angular의 Incremental DOM 방식 중에서 선택할 때 고려해야 할 요소는 어떤 것들이 있을까요?_<br><br>
   React와 Angular의 선택은 프로젝트의 특성과 개발자의 선호도에 따라 다를 수 있습니다. React는 가상 DOM과 컴포넌트 중심의 생태계로 유연한 UI 개발을 지원하며, Angular는 강력한 기능과 양방향 데이터 바인딩을 제공하여 기업급 애플리케이션을 구축하는 데 적합합니다. 장단점을 고려하여 프로젝트 요구사항과 개발 팀의 우선순위에 따라 선택해야 합니다.

## 43. seo란?

SEO(Search Engine Optimization)란 검색 엔진 최적화를 의미합니다. SEO는 웹 사이트 또는 웹 페이지가 검색 엔진 결과 페이지(SERP)에서 상위에 노출되도록 최적화하는 작업을 포괄적으로 말합니다.
크롤링, 색인, 메타태그를 통해 이루어진다. 검색포털일때와 아닌때 구분한다.

크롤링: 검색엔진이 온라인에 있는 문서를 수집하는 과정
색인: 크롤링한 데이터를 백과사전 형태로 등록하는 과정
메타태그: 검색 엔진이 웹 페이지를 색인할 때 사용됩니다. 제목(meta title)은 웹 페이지의 주요 주제를 나타내고, 설명(meta description)은 웹 페이지의 내용을 간략하게 설명하며, 키워드(meta keywords)는 웹 페이지의 주요 키워드를 제공합니다. 이러한 정보는 검색 엔진이 웹 페이지를 이해하고 관련 검색어와의 일치도를 평가하는 데 도움을 줍니다.

예상질문 <br>
->

1. _SEO를 개선하기 위해 어떤 요소들을 고려해야 할까요?_<br><br>
   SEO를 개선하기 위해 고려해야 할 요소들은 다양합니다. 여기에는 키워드 연구와 최적화, 웹 사이트의 구조와 내부 링크, 웹 페이지의 메타태그 최적화, 고품질의 콘텐츠 작성, 사용자 경험 개선, 사이트의 속도 최적화, 모바일 호환성, 외부 링크의 획득 등이 포함될 수 있습니다.

2. _검색 엔진은 어떻게 웹 사이트를 크롤링하고 색인하나요?_<br><br>
   검색 엔진은 웹 사이트를 크롤링하고 색인하기 위해 웹 크롤러 또는 스파이더라고 불리는 프로그램을 사용합니다. 이 프로그램은 웹 사이트를 따라가며 링크를 따라 이동하고, HTML 콘텐츠를 수집하여 검색 엔진의 색인 데이터베이스에 저장합니다. 크롤러는 웹 사이트의 로봇.txt 파일을 참조하여 수집 가능한 페이지를 결정하며, 메타태그 등의 정보를 활용하여 페이지의 주제와 내용을 파악합니다.

3. _검색포털과 일반적인 검색 엔진에서 SEO를 고려하는 점에는 어떤 차이가 있을까요?_<br><br>
   검색포털은 검색 엔진을 포함하는 종합적인 웹 플랫폼이며, 검색 엔진 결과뿐만 아니라 다양한 추가 정보와 서비스를 제공합니다. 일반적인 검색 엔진은 주로 검색 결과에 초점을 맞추고 있으며, 웹 사이트의 콘텐츠와 구조를 분석하여 순위를 결정합니다. 검색포털에서 SEO를 고려할 때에는 검색 결과 노출뿐만 아니라 포털의 다른 서비스(뉴스, 이미지, 비디오 등)에 대한 최적화도 고려해야 합니다.

4. _검색 엔진 최적화를 위해 주의해야 할 기술적인 요소나 방법은 어떤 것이 있을까요?_<br><br>
   검색 엔진 최적화를 위해 주의해야 할 기술적인 요소와 방법으로는 다음과 같은 것들이 있습니다: 적절한 키워드 연구와 키워드 최적화, 사이트의 속도 최적화, 모바일 최적화, 사이트의 구조와 내부 링크 구성 개선, 메타태그 최적화, 고품질의 콘텐츠 작성, 외부 링크의 획득과 내부 링크의 최적화, 소셜 미디어 활용, 사용자 경험 개선 등입니다. 이러한 요소들을 고려하여 검색 엔진에게 사이트의 신뢰성과 관련성을 전달하고 노출을 향상시킬 수 있습니다.

## 44. 이벤트 위임이란?

이벤트 위임(Event Delegation)은 동적으로 생성되는 하위 요소들에 대한 이벤트 처리를 상위 요소에서 담당하는 패턴입니다. 이벤트 위임은 상위 요소에 이벤트 리스너를 등록하고, 이벤트가 발생한 하위 요소에서 상위 요소로 이벤트가 전파되어 처리되도록 합니다.

예상질문<br>
->

1. _이벤트 위임을 사용하는 이유는 무엇인가요?_<br>

- 동적으로 생성되는 요소들에 대한 이벤트 처리를 효율적으로 관리할 수 있습니다.
- 각 하위 요소에 개별적으로 이벤트 리스너를 등록하는 것보다 메모리 사용과 성능 면에서 효율적입니다.
- 코드의 유지 보수성과 확장성을 높여줍니다.

2. _이벤트 위임이 어떻게 동작하나요? 전파되는 방식은 어떻게 이루어지나요?_<br><br>
   이벤트 위임은 이벤트의 전파 메커니즘을 활용하여 동작합니다.

- 상위 요소에 이벤트 리스너를 등록하고, 하위 요소에서 이벤트가 발생하면 이벤트는 상위 요소로 전파됩니다.
- 전파되는 이벤트는 이벤트 객체의 타겟(target) 속성에 따라 어떤 하위 요소에서 발생했는지 식별할 수 있습니다.

3. _이벤트 위임을 구현할 때 고려해야 할 사항이 있나요?_<br>

- 이벤트가 발생한 하위 요소 중에서 처리해야 할 요소를 식별해야 합니다.
- 상위 요소에서 처리하는 이벤트 리스너는 가능한 범용적으로 작성해야 합니다.
- 이벤트 전파를 막는 경우에는 이벤트 위임이 동작하지 않을 수 있으므로 주의해야 합니다.

4. _이벤트 위임이 다른 이벤트 처리 방식과 비교했을 때 어떤 장점이 있을까요?_<br>

- 동적으로 생성되는 요소들에 대한 이벤트 처리를 간편하게 관리할 수 있습니다.
- 이벤트 리스너의 수를 줄여 메모리 사용과 성능을 향상시킬 수 있습니다.
- 새로운 요소가 추가되어도 추가적인 이벤트 등록이 필요 없어 코드의 유지 보수성과 확장성을 향상시킵니다.

5. _이벤트 위임을 사용할 때 주의해야 할 점이 있을까요?_<br>

- 이벤트가 상위 요소로 전파되므로, 의도하지 않은 요소에서 이벤트가 처리될 수 있습니다.
- 이벤트 리스너의 범용성을 고려하여 처리 로직을 작성해야 합니다.
- 이벤트 전파를 막는 경우에는 이벤트 위임이 동작하지 않으므로 조심해야 합니다.

## 45. 메모이 제이션이란?

메모이제이션(memoization)이란 프로그래밍을 할 때 반복되는 결과를 메모리에 저장함으로써 이후 같은 결과가 사용될 때 저장한 값을 이용해 빠르게 실행하는 코딩 기법을 말한다.

예상질문 <br>
->

1. _메모이제이션을 사용하는 것이 항상 성능 향상을 가져오는 것은 아닐 수도 있습니다. 어떤 경우에 메모이제이션을 사용하지 않는 것이 좋을까요?_<br>

- 입력값이 너무 많아서 메모리 부족이 발생할 수 있는 경우.
- 함수의 반환 값이 항상 변하는 경우(예: 난수 생성).
- 함수의 실행 시간이 아주 짧아서 메모이제이션의 오버헤드가 성능 향상에 영향을 미치지 않는 경우.

2. _메모이제이션을 구현하기 위해 어떤 방법을 사용할 수 있을까요? 일반적으로 어떤 자료구조를 사용하면 좋을까요?_<br><br>
   메모이제이션을 구현하기 위해 일반적으로는 함수의 반환 값을 저장하기 위한 캐시(또는 해시 테이블)를 사용합니다. 자료구조는 선택한 프로그래밍 언어나 환경에 따라 달라질 수 있지만, 해시 맵 또는 딕셔너리와 같은 키-값 구조를 사용하는 것이 흔한 방법입니다.

3. _메모이제이션을 구현할 때 고려해야 할 주요 요소는 무엇인가요? 어떤 상황에서 잘못된 결과가 반환될 수 있을까요?_<br>

- 입력값의 유일성: 메모이제이션은 입력값에 기반하여 결과를 저장하므로, 입력값의 유일성을 보장해야 합니다.
- 캐시 크기 제한: 메모리 사용을 제어하기 위해 캐시의 크기를 제한해야 할 수 있습니다.
- 부작용(side effects): 메모이제이션된 함수가 부작용을 가지는 경우(예: 외부 상태 변경) 잘못된 결과가 반환될 수 있습니다.

4. _메모이제이션을 사용하는 것은 코드의 가독성과 유지 보수성에 어떤 영향을 미칠까요? 어떤 상황에서 메모이제이션을 사용하는 것이 코드를 복잡하게 만들 수 있을까요?_<br><br>
   메모이제이션은 코드의 가독성과 유지 보수성에 영향을 줄 수 있습니다. 메모이제이션을 적용하면 함수 내부에 캐시 로직이 추가되므로 코드가 복잡해질 수 있습니다. 또한, 메모이제이션은 순수한(pure) 함수에서만 사용해야 하며, 부작용이 있는 함수에 적용하면 예상치 못한 동작이 발생할 수 있습니다. 따라서 적절한 상황에서 사용하고 코드를 명확하게 문서화하고 주석 처리하여 가독성과 유지 보수성을 유지해야 합니다.

## 46. 이벤트 버블링이란?

자식요소에서 click 이벤트가 일어났을때 그 이벤트가 최상위 요소까지 전파되는 현상
이벤트 버블링을 임의적으로 막을수 있음// event.stopPropagation 속성 사용하면 됨

예상질문 <br>
->

1. _이벤트 버블링을 어떻게 멈출 수 있을까요? 즉, 이벤트 전파를 중지시키는 방법은 무엇이 있을까요?_<br><br>
   이벤트 버블링을 멈출 수 있는 방법은 event.stopPropagation()을 사용하는 것입니다. 이 메서드를 호출하면 이벤트의 전파가 중단되고, 상위 요소로의 이벤트 전파가 멈춥니다.

2. _이벤트 버블링과 관련하여 이벤트 캡처링(capturing)이라는 개념이 있습니다. 이벤트 캡처링은 무엇이며, 이벤트 버블링과 어떻게 다른지 설명해주세요._<br><br>
   이벤트 캡처링은 이벤트가 상위 요소에서 하위 요소로 전파되는 반대 방향의 과정을 말합니다. 이벤트 캡처링은 이벤트가 최상위 요소부터 시작하여 하위 요소까지 차례대로 전파됩니다. 이벤트 캡처링은 이벤트 버블링과는 반대의 방향으로 진행되지만, 일반적으로 자주 사용되는 개념은 이벤트 버블링입니다.

3. _이벤트 버블링은 UI 개발에서 어떤 상황에서 유용하게 활용될 수 있을까요? 어떤 경우에 이벤트 버블링을 적용하면 편리한지 예를 들어 설명해주세요._<br><br>
   이벤트 버블링은 UI 요소의 중첩 구조에서 이벤트 처리를 편리하게 만들어줍니다. 만약 여러 개의 하위 요소들이 동일한 이벤트를 처리해야 하는 경우, 이벤트 버블링을 활용하여 상위 요소에 이벤트 리스너를 등록하면 모든 하위 요소에서 발생한 이벤트를 한 번에 처리할 수 있습니다.

4. _이벤트 버블링은 자바스크립트 이외의 다른 언어나 프레임워크에서도 적용되는 개념인가요? 비슷한 개념이 있는 경우에는 어떤 용어로 불리는지 알려주세요._<br><br>
   이벤트 버블링은 자바스크립트의 DOM 이벤트 모델에서 주로 사용되는 개념입니다. 다른 언어나 프레임워크에서는 유사한 개념이 존재할 수 있으며, 예를 들면 Java의 AWT나 Swing에서는 이벤트 전파와 관련된 개념이 있습니다. 그러나 각 언어나 프레임워크마다 용어와 동작 방식은 조금씩 다를 수 있습니다.

## 47. 부모에서 자식으로 이벤트 상속 방법?

이벤트 캡처링으로 부모에서 자식으로 이벤트를 상속할 수 있습니다. 이벤트 캡처링은 이벤트 버블링과 반대로 상위 요소에서 하위 요소로 탐색하며 이벤트를 전파하는 방식입니다.// 리액트에서는 이벤트 캡처링보다
이벤트 버블링을 더 많이 사용합니다.

예상질문 <br>
->

1. _이벤트 캡처링을 통해 부모에서 자식으로 이벤트를 전파할 때, 중간에 다른 하위 요소들이 있는 경우 어떤 순서로 이벤트가 전파되는지 알려주세요._<br><br>
   이벤트 캡처링을 통해 부모에서 자식으로 이벤트를 전파할 때, 이벤트는 상위 요소에서 하위 요소로 탐색하며 전파됩니다. 즉, 가장 상위 요소부터 차례대로 하위 요소까지 이벤트가 전달됩니다.

2. _이벤트 캡처링을 사용할 때 주의해야 할 점은 무엇인가요? 잘못된 사용으로 인해 발생할 수 있는 문제가 있을까요?_<br><br>
   이벤트 캡처링을 사용할 때 주의해야 할 점은 이벤트 핸들러를 등록하는 단계에서 이벤트 캡처링을 명시적으로 설정해야 한다는 것입니다. 또한, 이벤트 캡처링을 사용하는 경우 중간에 있는 다른 요소들이 이벤트 전파를 막지 않도록 주의해야 합니다.

3. _이벤트 캡처링을 이용하여 부모에서 자식으로 이벤트를 상속하는 것의 장점과 단점은 무엇인가요?_<br><br>
   이벤트 캡처링을 이용하여 부모에서 자식으로 이벤트를 상속하는 장점은 상위 요소에서 하위 요소로 이벤트를 한 번에 전달할 수 있다는 것입니다. 이를 통해 중복된 이벤트 핸들러 등록을 방지하고 코드의 가독성과 유지 보수성을 향상시킬 수 있습니다. 단점은 이벤트 전파 경로가 길어질 수 있고, 이벤트 핸들링 로직이 복잡해질 수 있다는 점입니다.

4. _이벤트 캡처링과 이벤트 버블링은 어떤 상황에서 사용하는 것이 적합한가요? 상황에 따라 선택해야 하는 요인은 무엇인가요?_<br><br>
   이벤트 캡처링과 이벤트 버블링은 사용하는 상황에 따라 다릅니다. 이벤트 캡처링은 상위 요소에서 하위 요소로 이벤트를 전파해야 할 경우에 적합합니다. 이벤트 버블링은 하위 요소에서 상위 요소로 이벤트를 전파해야 할 경우에 적합합니다. 선택하는 요인은 이벤트의 처리 순서, 이벤트 전파 경로, 코드 구조 등을 고려해야 합니다.

## 48. 이벤트버블링을 막는방법?

1. stopPropagation(): 이벤트 객체의 stopPropagation() 메서드를 호출하여 이벤트 버블링을 중단할 수 있습니다. 이 메서드를 호출하면 현재 이벤트가 상위 요소로의 전파를 멈추고, 추가적인 이벤트 핸들링이 발생하지 않습니다. 예를 들어, 다음과 같이 이벤트 핸들러에서 stopPropagation()을 사용할 수 있습니다:

이렇게 호출된 stopPropagation()은 이벤트의 상위 요소로의 전파를 막아주므로, 상위 요소들에서 이벤트가 처리되지 않습니다.

2. stopImmediatePropagation(): 이벤트 객체의 stopImmediatePropagation() 메서드를 호출하여 이벤트 버블링과 함께 현재 요소에서의 추가 이벤트 핸들링을 멈출 수 있습니다. 이 메서드를 호출하면 현재 이벤트가 상위 요소로의 전파를 멈추고, 같은 요소에서 추가적인 이벤트 핸들링도 중지됩니다. 예를 들어, 다음과 같이 이벤트 핸들러에서 stopImmediatePropagation()을 사용할 수 있습니다:

이렇게 호출된 stopImmediatePropagation()은 이벤트의 상위 요소로의 전파뿐만 아니라 같은 요소에서의 추가 이벤트 핸들링까지 막아주므로, 다른 이벤트 핸들러도 실행되지 않습니다.

예상질문 <br>
->

1. _stopPropagation()과 stopImmediatePropagation()의 차이점은 무엇인가요?_<br><br>
   stopPropagation()은 현재 이벤트의 상위 요소로의 전파를 멈추지만, 같은 요소에서의 추가 이벤트 핸들링은 허용합니다. 반면에 stopImmediatePropagation()은 상위 요소로의 전파를 멈추고, 같은 요소에서의 추가 이벤트 핸들링까지도 중지합니다.

2. _stopPropagation() 또는 stopImmediatePropagation() 메서드를 사용할 때 주의해야 할 점은 무엇인가요?_<br><br>
   stopPropagation() 또는 stopImmediatePropagation()을 사용할 때 주의해야 할 점은, 이벤트 버블링이나 추가 이벤트 핸들링이 정말로 중지되어야 하는지 신중하게 판단해야 한다는 점입니다. 잘못 사용하면 다른 요소나 기능에 영향을 줄 수 있으므로, 사용에 주의가 필요합니다.

3. _이벤트 버블링을 막는 대안적인 방법은 어떤 것이 있을까요?_<br><br>
   이벤트 버블링을 막는 대안적인 방법으로는 이벤트 캡처링을 활용하는 것이 있습니다. 이벤트 캡처링은 이벤트를 최하위 요소부터 상위 요소로 탐색하며 처리하기 때문에, 원하는 요소에 직접적으로 이벤트 핸들러를 등록할 수 있습니다.

4. _이벤트 캡처링 단계에서 이벤트를 중단하는 방법은 무엇인가요?_<br><br>
   이벤트 캡처링 단계에서 이벤트를 중단하기 위해서는 이벤트 핸들러에서 event.stopPropagation()을 호출하면 됩니다. 이렇게 호출되면 이벤트는 상위 요소로의 전파를 막고, 해당 요소에서 추가 이벤트 핸들링이 중지됩니다.

## 49. 이벤트버블링 활용방법?

1. 이벤트 위임(Event Delegation): 상위 요소에 이벤트 리스너를 등록하고, 하위 요소에서 발생하는 이벤트를 상위 요소에서 처리하는 패턴입니다. 이를 통해 동적으로 생성된 요소에도 이벤트를 적용할 수 있고, 이벤트 핸들링 코드를 간결하게 유지할 수 있습니다. 예를 들어, 리스트에서 각 항목을 클릭할 때 특정 동작을 수행하는 경우, 상위의 리스트 요소에 클릭 이벤트를 등록하고 항목을 클릭할 때 이벤트가 버블링되도록 할 수 있습니다.

2. 이벤트 위임을 통한 성능 최적화: 많은 수의 하위 요소에 각각 이벤트 리스너를 등록하는 것보다 상위 요소에 하나의 이벤트 리스너를 등록하는 것이 메모리와 성능 면에서 효율적일 수 있습니다. 예를 들어, 테이블의 각 셀에 이벤트 리스너를 등록하는 대신, 테이블 전체에 이벤트 리스너를 등록하여 셀 클릭 이벤트를 처리할 수 있습니다.

3. 이벤트 위임을 통한 동적 요소 관리: 동적으로 생성되는 요소에 이벤트를 적용할 때 이벤트 버블링을 활용하여 관리할 수 있습니다. 예를 들어, 리스트에 새로운 항목이 추가되었을 때 각 항목에 이벤트를 등록하는 대신, 리스트 요소에 이벤트 리스너를 등록하고 새로운 항목이 추가될 때 자동으로 해당 이벤트가 적용되도록 할 수 있습니다.

예상질문<br>
->

1. _이벤트 위임을 사용할 때 주의해야 할 사항은 무엇인가요? 이벤트 위임이 잘못 사용될 경우 어떤 문제가 발생할 수 있을까요?_<br><br>
   이벤트 위임을 사용할 때 주의해야 할 사항은, 상위 요소에 등록된 이벤트 리스너가 하위 요소에 영향을 미칠 수 있다는 점입니다. 따라서, 상위 요소에 등록된 이벤트 리스너가 모든 하위 요소에서 처리되어야 하는 것이 아니라면, 이벤트가 의도치 않게 상위 요소로 전파되는 것을 방지하기 위해 조건문 등을 활용하여 적절한 처리를 해주어야 합니다.

2. _이벤트 버블링을 활용하여 처리되는 이벤트는 어떤 종류가 있을까요? 예를 들어, 클릭 이벤트 외에도 어떤 이벤트가 이벤트 버블링을 통해 상위 요소로 전파될 수 있을까요?_<br><br>
   이벤트 버블링을 활용하여 처리되는 이벤트는 클릭 이벤트 외에도 마우스 이벤트(마우스 오버, 마우스 아웃 등), 키보드 이벤트(키 누름, 키 뗌 등), 포커스 이벤트(요소에 포커스가 되거나 포커스가 사라짐 등) 등 다양한 종류의 이벤트가 있습니다.
3. _이벤트 버블링을 활용하여 이벤트를 처리할 때, 이벤트의 소스 요소를 어떻게 식별할 수 있을까요? 이벤트 핸들러에서 식별을 위한 추가적인 작업이 필요한가요?_<br><br>
   이벤트 핸들러에서 이벤트의 소스 요소를 식별하기 위해 event.target을 활용할 수 있습니다. event.target은 실제 이벤트가 발생한 요소를 가리키는 포인터입니다. 이를 활용하여 필요한 작업을 수행할 수 있습니다.

4. _이벤트 위임을 사용하여 처리되는 이벤트는 어떤 경우에 유용하게 적용될 수 있을까요? 어떤 상황에서 이벤트 위임을 고려해볼 만한 가치가 있을까요?_<br><br>
   이벤트 위임은 동적으로 생성되는 요소에 이벤트를 적용하거나, 여러 요소에 동일한 이벤트를 적용해야 할 때 유용합니다. 예를 들어, 리스트나 테이블 등에 항목이 동적으로 추가되거나 변경될 때, 각 항목에 개별적으로 이벤트를 등록하는 대신 상위 요소에 이벤트를 등록하여 효율적으로 이벤트 처리를 할 수 있습니다. 이를 통해 코드의 가독성과 유지 보수성을 향상시킬 수 있습니다.

## 50. React 왜사용하시나요?

저는 가상돔 시스템에 매력을 느껴 사용하고 있습니다. 리액트는 가상돔이라는 개념을 접목시켜 기존 dom과 비슷한 가상돔을 만들고, 컴포넌트의 상태가 바뀔때마다 가상돔과 dom을 비교하여 바뀐부분만 렌더링 되는 부분이 저에게 메리트가 되었습니다.

예상질문 <br>
->

1. _리액트의 가상돔(Virtual DOM)을 사용하는 것이 실제 DOM과 비교하여 성능 향상을 가져올 수 있는 이유는 무엇인가요?_<br><br>
   리액트의 가상돔은 실제 DOM과 비교하여 변경된 부분을 최소화함으로써 성능 향상을 가져옵니다. 가상돔은 가볍고 빠르게 메모리에서 동작하며, 실제 DOM 조작은 최소한으로 이루어집니다. 이는 렌더링 과정에서 필요한 변경 사항만을 업데이트하고 나머지는 건너뛰는 효과를 가져옵니다.

2. _가상돔의 동작 방식에 대해 좀 더 설명해주실 수 있을까요?_<br><br>
   가상돔은 리액트에서 컴포넌트의 상태 변경 시 새로운 가상돔 트리를 생성하고 기존 가상돔 트리와 비교합니다. 변경된 부분만을 파악하여 실제 DOM에 적용합니다. 이를 통해 실제 DOM 조작 횟수를 최소화하고, 렌더링 성능을 향상시킵니다.

3. _리액트의 가상돔은 어떤 상황에서 특히 유용한가요? 어떤 종류의 애플리케이션 개발에 가장 적합한가요?_<br><br>
   리액트의 가상돔은 대규모 애플리케이션에서 특히 유용합니다. 대규모 애플리케이션에서는 컴포넌트들의 상태 변화가 빈번하게 일어날 수 있으며, 실제 DOM 조작은 성능 저하를 유발할 수 있습니다. 가상돔을 사용하면 변경된 부분만을 업데이트하기 때문에 효율적인 렌더링을 할 수 있습니다.

4. _가상돔을 사용하는 것이 항상 장점만 있는 것은 아닌가요? 가상돔을 사용함으로써 발생할 수 있는 단점이나 주의해야 할 점이 있을까요?_<br><br>
   가상돔을 사용하는 것은 항상 장점만 있는 것은 아닙니다. 가상돔을 생성하고 비교하는 과정은 일정한 오버헤드를 가지며, 복잡한 컴포넌트 구조에서는 가상돔 생성 및 비교 과정이 비용이 크게 증가할 수 있습니다. 또한, 가상돔의 적용이 필요하지 않은 단순한 UI나 정적인 콘텐츠를 다룰 때는 가상돔의 이점이 크게 나타나지 않을 수 있습니다. 따라서 개발자는 상황에 맞게 가상돔을 사용할지 결정해야 합니다.

   skrrrrr
